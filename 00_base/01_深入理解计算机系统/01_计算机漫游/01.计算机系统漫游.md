#### 计算机系统漫游

- 计算机系统是由**硬件**和**系统软件**组成的，他们共同工作来运行应用程序。

##### 学习目标

- 如何避免由计算机表示数字的方式引起的奇怪的数字错误
- 通过一些小窍门来优化自己的C代码，以充分可利用现代处理器和存储器系统的设计
- 了解编译器是如何实现过程调用的
- 如何避免缓冲区溢出错误带来的安全漏洞。
- 如何识别和避免链接时讨厌的错误
- 学会如何编写自己的Unix shell，自动的动态存储分配包，甚至自己的Web服务器
- 认识并发带来的希望和陷阱

**实例：** hello程序是如何运行的？

~~~c
环境： Mac
1.新建hello.c文件，文件内容如下：
#include <stdio.h>
int main()
{
	printf("hello ,world t \n");
	return 0;	
}
2.然后使用gcc 编译该.c文件： gcc hello.c
3.会生成 a.out可执行文件，运行该执行文件： ./a.out
4.控制台输出内容：
  hello ,world t
~~~

- .c文件运行的生命周期 — 问题研究点？
  - 从被程序员创建开始 — 一个源文件(.c)是如何被系统软件加载的？
  - 到在系统上运行 — 系统软件又是如何运行hello程序的？
  - 输出简单的消息 — 如何输出到电脑屏幕上的？

#### 1.1.信息就是位 + 上下文

- 上面运行的hello程序，其生命周期是从一个源文件开始的（源文件就是程序员创建并编辑保存的文本文件），文件名是hello.c
  - 源文件实际上就是一个由值0和1组成的位（也叫比特-bit），8个位组成一个字节，每个字节表示程序中某些文本字符
  - hello.c程序是以字节序列（使用ASCII标准来表示每个文本字符）的方式存储在文件中的，每个字节都有一个整数值，对应于某些字符
  - 像hello.c这样只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件

<img src=".\res\1.hello.c源文件ASCII文本文件.png" alt="1.hello.c源文件ASCII文本文件" style="zoom:100%;" />

- 上下文
  - 系统中所有的信息--包括磁盘文件，内存中的程序，内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。
  - 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数，浮点数，字符串或者机器指令（？？？）
  - 了解数字的机器表示方式，整数于实数的不同 -- 详见第二章

#### 1.2.程序被其他程序翻译成不同的格式

- hello程序的生命周期是从一个高级C语言程序开始的，hello.c文件也叫源文件，其文件内容能够被人读懂。
- 为了能使hello程序在系统上运行，每条C语言都必须被系统程序转化位一系列低级机器语言指令。因为计算机看不懂C语言文件，它只认识机器语言，所以要让系统运行hello.c程序，需要先将c语言程序转换成机器语言文件
  - 然后这些指令按照**可执行目标程序**的格式打好包，并以二进制磁盘文件的形式存放起来，目标程序也叫做可执行目标文件

##### 编译流程

- 从C语言源文件到目标文件的转化是由编译器驱动程序完成的，可通过命令行执行该操作：

~~~c
gcc -o hello hello.c
~~~

- gcc 命令会调用编译器驱动程序读取源程序文件hello.c,并把它翻译成一个可执行目标文件hello。这个翻译过程可分为四个阶段完成：
  - 预处理器 -> 编译器 -> 汇编器 -> 链接器

<img src=".\res\2.编译流程（包括四个阶段）.png" alt="2.编译流程（包括四个阶段）" style="zoom:100%;" />

**1.预处理阶段：** 预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。

- 比如hello.c中第1行的#include<stdio.h> 命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文件中。最后得到另一个c程序，最后生成hello.i 文件

**2.编译阶段：** 编译器（ccl）将文本文件hello.i 翻译成文本文件hello.s,它包含一个汇编语言程序，它包含函数main的定义

- 每条汇编语句对应一条机器语言指令

**3.汇编阶段：** 汇编器（as）将hello.s翻译成机器语言指令，并把指令打包成一个叫做**可重定位目标程序**的格式，并将结果保存在目标文件hello.o中（二进制文件）

**4.链接阶段：** hello程序中调用了printf函数，该函数是每个C编译器都提供的标准C库中的一个函数。

- printf函数存在于一个名为printf.o的单独预编译好的目标文件中，而这个文件需要以某种方式合并到我们的hello.o程序中。
- 链接器（ld）就负责处理这种合并，结果就得到hello文件，它是一个可执行目标文件，可以被加载到内存中，由系统执行。

#### 1.3 了解编译系统是如何工作的

- 像hello.c这样简单的程序，可以依靠编译系统生成正确有效的机器代码，但同时作为高级程序员需要了解编译是如何运行开发者编写好的程序，还有其他原因促使我们学习编译器：
  - 优化程序性能：
    - 了解一些机器代码以及编译器将不同的C语句转化位机器代码的方式：
    - 比如，switch语句是否比一系列if-else高效？
    - 一个函数调用的开销是多大？
    - while循环比for循环更有效吗？
    - 指针引用比数组索引更有效吗？
    - 在循环求和中，将结果放在一个本地变量中，比放在一个通过引用传递过来的参数中，为什么运行效率快很多？
    - 使用括号从新排列一下算术表达式能让函数运行地更快吗？
  - 理解链接时出现的错误：
    - 静态变量与全局变量的区别？
    - 动态库与静态库的区别
  - 避免安全漏洞：
    - 堆栈原理
    - 缓冲区溢出错误

#### 1.4.处理器读并解释储存在内存中的指令

- 当hello.c源程序被编译系统翻译成可执行目标文件hello后，是被保存在磁盘上的。要想在Unix系统上运行该可执行文件，可以通过shell应用程序来运行。









