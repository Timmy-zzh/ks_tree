#### 0.信息的表示和处理

- 现代计算机存储和处理的信息以二值信号表示:

- 三种重要的数字表示：
  - 1.无符号编码：基于传统的二进制表示法，表示大于或者等于零的数字
  - 2.补码编码：表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字
  - 3.浮点数编码：时表示实数的科学计数法的以2为基数的版本
- 计算机的表示法是用有限数量的位来对一个数字编码，当结果值太大以致不能表示时，某些运算就会溢出（overflow）
  - 例如：表达式 200 * 300 * 400 * 500 = - 884 901 888
- 整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的。
  - 而浮点数虽然可以编码一个较大的数值范围，但是这种表示知识近似的。
- 位级的算术运算

#### 1.信息存储

- 大多数计算机使用8位的块（字节），最为最小的可寻址的**内存单位**，而不是访问内存中单独的位
  - 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。
  - 内存的那个字节都由一个唯一的数字来标识，称为地址
  - 所有可能地址的集合称为虚拟地址控件
- 编译器和运行时系统将存储器空间划分为可管理的单元，用来存放不同的程序对象。（程序数据，指令和控制信息）

##### 16进制表示法

- 16进制以0x位开头数字常量，使用数字 0~9和 A~F 来表示16个可能的值

![1.16进制表示法](.\res\1.16进制表示法.png)

##### 字数据大小

- 字长：指明指针数据的标称大小，虚拟地址以一个字来编码，字长决定虚拟地址空间的最大大小
- 32位字长机器和64位字长机器，标识32（64）位字长限制虚拟地址空间
  - 大多数64位机器也可以运行为32位机器编码的程序，这是一种向后兼容
  - 有些数据类型的确切字节数依赖于程序是如何被编译的。
    - 数据类型long在32位程序中为4字节，在64位程序中则为8字节
    - ISO 99引入了一类数据大小固定的数据类型，int32_t和 int64_t

<img src=".\res\2.C语言支持的整数和浮点数的数据格式.png" alt="2.C语言支持的整数和浮点数的数据格式" style="zoom:99%;" />

##### 寻址和字节顺序

- 有很多程序对象的地址是跨越多个字节的，它有两个规则：这个对象的地址是什么，以及在内存中如何排列这些字节。
  - 例如一个类型为int的变量x的地址为0x100，假设在32位字长机器中，变量x在内存中占用4个字节来存储，使用的内存地址为：0x100,0x101,0x102和0x103位置
- 排列一个对象的字节的规则：大端法和小端法
  - 最高有效位在最前面的方式：称为大端法
  - 最低有效字节在最前面的方式：称为小端法
- 例如：变量x的的类型为int，它的十六进制值为0X01234567,它位于地址0x100处，所以变量x的地址范围为0x100~0x103在内存中的字节顺序如下

<img src=".\res\3.大端法和小端法.png" alt="3.大端法和小端法" style="zoom:90%;" />

##### 字符串表示

- C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组

##### 布尔代数

- 通过将逻辑值true（真）和false（假）编码为二进制值1和0，设计一种代数

##### 位级运算

- OR（或） |
- AND（与）&
- NOT（取反）~
- EXCLUSIVE-OR（异或）^

##### 逻辑运算

- OR - ||
- AND - &&
- NOT - ！

逻辑运算认为所有非零的参数都表示true，而参数0表示false

##### 移位运算

向左或者向右移动位模式

- x向左移动k位，丢弃最高的k位，并在右端补k个0
- 逻辑右移在左端补k个0
- 算术右移在左端补k个最高有效位的值

![4.移位运算](.\res\4.移位运算.png)

#### 2.整数表示

- 用位来编码整数：
  - 一种只能表示非负数 （无符号整数，声明为unsigned）
  - 另一种能够表示负数，零和正数 （有符号整数）

![5.整数数据类型的取值范围](.\res\5.整数数据类型的取值范围.png)

##### 无符号数编码

- 无符号数的二进制表示，每个介于0~2^w-1之间的数都有一个唯一w位的值编码
  - 例如十进制值11作为无符号数，只有一个4位的表示：[1011]

##### 补码编码

- 有符号数的计算机表示方式是补码形式，用于表示负数值。
  - 将字的最高有效位解释位负权
  - 最高位为符号位，设置为1，表示负数； 设置为0值为非负
- 补码表示范围：
  - 最小值为向量[100...0] = -2^(w-1), 最大值为向量[011....1] = 2^(w-1) -1
  - 以长度4为例：[1000] = -8 ;    [0111] = 7

##### 有符号数与无符号数之间的转换

- 假设变量x声明为int，变量u声明为unsigned，表达式(unsigned)x 会将x的值转换成一个无符号的数值。而(int)u将u的值转换成一个有符号整数。
  - 对于两种形式中都能表示的值，可以保持不变
  - 另一方面，将负数转换成无符号可能会得到0。如果转换的无符号数太大以致超出补码能过够表示的范围，可能会得到TMax =  2^(w-1) -1

<img src=".\res\6.有符号数与无符号数转换.png" alt="6.有符号数与无符号数转换" style="zoom:80%;" />

##### 为什么会这样：

- 因为强制类型转换的结果保持位值不变，只是改变了解释这些位的方式
- -12345 的位值为：1110001111110011
- 53191  的位值位：1110001111110011

#### 3.整数运算

- 问题：两个正数相加会得出一个负数，比较表达式x<y 和比较表达式x-y<0 会产生不同的结果

##### 无符号加法：

- 两个非负整数x和y，满足0<= x,y< 2^w,每个数都能表示为w位无符号数字。然而他们的和，可能的范围为0<= x+y <= 2^(w+1)-2,需要w+1位表示。
  - 例如考虑一个4位数的加法x+y，x=9位表示为[1001] ,y=12 位表示位[1100],他们的和是21，需要5位才能表示[10101],如果丢弃最高位，得到最后的结果[0101]=5

##### 补码加法

##### 补码非：

~~~java
0101：--》 5
1011：--》-5     
-5是由5取反+1得到： 
^ 0101  ---5取反
-------
  1010 
+    1    ---+1
-------
  1011   ---最后得到-5
~~~

#### 4.浮点数

##### IEEE浮点表示：使用 V=(-1) ^s * M * 2^E来表示一个数

- 其中**符号s**决定这数是负数（s=1）还是正数(s=0),而对于数值0的符号位解释作为特殊情况处理
- **尾数M：**是一个二进制小数，它的范围是1~2-e，或者是0~1-e
- **阶码：**E的作用是对浮点数加权，这个权重是2的E次幂（可能是负数）

##### 浮点数的位表示划分：

- 一个单独的符号位s直接编码符号s
- k位的阶码字段exp=ek...e1e0编码阶码E
- n位小数字段frac=fn...f1f0编码尾数M

下面是32位和64位字长下浮点数的位级编码：

![7.标准浮点格式](.\res\7.标准浮点格式.png)

##### demo练习：

~~~java

~~~



#### 5.总结

- 计算机将信息编码为位（比特），通常组织成字节序列。
- C语言的设计可以包容多种不同字长和数字编码的实现。64位机器也可以运行为32位机器编译的程序
- 大多数机器对整数使用补码编码，而对浮点数使用IEEE标准编码。
- 在相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现遵循的原则是底层的位模式不变























