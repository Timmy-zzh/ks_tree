

> 重点知识：Tcp SYN 建立链接的过程 Wireshark TcpDump  基础的网络知识(OSI) Socket 高层协议（WebSocket、Quic、Http2、Https）





网络：底层很深 面试很容易说 知识点套路固定 

网络优化：

- 全链接的概念 （监测、aop+asm、数据（流量 url ）android线上APM
- 网络链接过程 
- DNS （httpDNS、网络直连、***）基础建构（业务）吹逼+KPI
- 弱网优化（切换）定义？

### 网络编程概述

什么是网络编程？网络编程主要的作用是什么？

- 通过操作相应 API 调度计算机硬件资源，并利用传输管道（网线）进行数据交换的过程；

- 网络编程，编的是传输层面的代码，在往下就是操作系统提供的功能，我们在传输层编的 TCP 或 UDP 的代码，会调用下层的接口，而这些接口是操作系统提供的；

#### OSI七层模型和TCP/IP五层模型

![image-20200808144002923](https://tva1.sinaimg.cn/large/007S8ZIlly1ghjec8bpb9j312w0le4gv.jpg)

- 应用层：HTTP，HTTPS，FTP，POP3、SMTP等。
- 传输层：TCP和UDP就是在这一层。端口号是这里的“端”。
- 网络层： IP

#### TCP/IP五层模型

![image-20200808144228864](https://tva1.sinaimg.cn/large/007S8ZIlly1ghjeepjympj312i0fak3d.jpg)

### 专业工具源码分析

TTCP：

http://www.freebsdsoftware.org/benchmarks/ttcp.html

https://linux.die.net/man/1/ttcp

![image-20210406101453152](https://i.loli.net/2021/04/06/95GgIKRTebmCJFq.png)

### TCP protocal

![image-20200813235837816](https://tva1.sinaimg.cn/large/007S8ZIlly1ghpmkvtj6xj31sc0pkas7.jpg)

- Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，IP地址用来区分不同主机的，源端口号和目的端口号配合上IP首部中的源IP地址就能确定为一个TCP连接。
- Sequenece Number:用来标识从TCP发送端向TCP接收端的数据字节流，他表示在这个报文中的第一个数据字节流在数据流中的序号；主要用来解决网络乱序的问题。
- Acknowledgment Number：32位确认序号包发送确认的一端所期望收到的下一个序号，因此，确认需要应该是上次已成功收到数据字节序号+1，不过只有当标志位中的ACK标志(下面介绍)为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。
- Offset:给出首部中32bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit(最多能表示15个32bit的字，即4*15=60个字节的首部长度)，因此TCP最多有60个字节的首部。然而，没有任选字段，正常的长度是20字节。
- TCP Flags:TCP首部中有6个比特，它们总的多个可同时被设置为1，主要是用于操控TCP的状态机，依次为URG，ACK，PSH，RST，**SYN**，FIN。

**总结**：三次握手建立连接的首要目的是「同步序列号」。

**标志位**

- URG:次标志表示TCP包的紧急指针域(后面马上就要说到)有效，用来保证TCP连接不被中断，并督促中间层设备要尽快处理这些数据。

- ACK:此标志表示应答域有效，就是说前面所说的TCP的应答将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。

- PSH:这个标志位表示Push操作。所谓Push操作就是是在数据包到达接受端以后，立即传送给应用程序，而不是在缓冲区排队。

- RST:这个标志位表示连接复位请求。用来复位哪些产生错误的链接，也被用来拒绝错误和非法的数据包。

- SYN:表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1。这个标志的数据包常常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口，但是由于这种扫描只是进行TCP三次握手的第一次握手，因此这种扫描的成功表明被扫描的机器很不安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手。

- FIN:表示发送端已经达到数据末尾，也就是说双方数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将断开。这个表示的数据包也经常被用于进行端口扫描。

![image-20200814000219997](https://tva1.sinaimg.cn/large/007S8ZIlly1ghpmoqze17j30u00y94qp.jpg)



**四次挥手的原因**

- 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。

这么做有两个理由：

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

**TCP状态机**

![这里写图片描述](https://i.loli.net/2021/04/06/H2DALCmpUnvkose.png)

（1）CLOSED 状态时初始状态。

（2）LISTEN:被动打开，服务器端的 状态变为LISTEN(监听)。被动打开的概念：连接的一端的应用程序通知操作系统，希望建立一个传入的连接。这时候操作系统为连接的这一端建立一个连 接。与之对应的是主动连接：应用程序通过主动打开请求来告诉操作系统建立一个连接。

（3）SYNRECVD:服务器端收到SYN后，状态为SYN；发送SYN ACK;

（4）SYN_SENTY:应用程序发送SYN后，状态为SYN_SENT；

（5）ESTABLISHED:SYNRECVD收到ACK后，状态为ESTABLISHED； SYN_SENT在收到SYN ACK，发送ACK，状态为ESTABLISHED；

（6）CLOSE_WAIT:服务器端在收到FIN后，发送ACK，状态为CLOSE_WAIT；如果此时服务器端还有数据需要发送，那么就发送，直到数据发送完毕；此时，服务器端发送FIN，状态变为LAST_ACK;

（7）FIN_WAIT_1：应用程序端发送FIN，准备断开TCP连接；状态从ESTABLISHED——>FIN_WAIT_1；

（8）FIN_WAIT_2：应用程序端只收到服务器端得ACK信号，并没有收到FIN信号；说明服务器端还有数据传输，那么此时为半连接；

（9）TIME_WAIT:有两种方式进入 该状态：1、FIN_WAIT_1进入：此时应用程序端口收到FIN+ACK（而不是像FIN_WAIT_2那样只收到ACK，说明数据已经发送完毕）并 向服务器端口发送ACK；2、FIN_WAIT_2进入：此时应用程序端口收到了FIN，然后向服务器端发送ACK；TIME_WAIT是为了实现TCP 全双工连接的可靠性关闭，用来重发可能丢失的ACK报文；需要持续2个MSL(最大报文生存时间)：假设应用程序端口在进入TIME_WAIT后，2个 MSL时间内并没有收到FIN,说明应用程序最后发出的ACK已经收到了；否则，会在2个MSL内在此收到ACK报文；

#### TCP 流量控制

双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在缓存区里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。对发送方发送速率的控制，我们称之为流量控制。

![SewrWdh3o7Dm9H8](https://i.loli.net/2021/04/06/JS4fOzWbuV5a2cT.png)


### UDP

- TCP 提供可靠交付，UDP继承了IP包的特性，不保证不丢失，不保证按时到达；
- TCP是面向字节流的，发送的时候发的是一个流，没头没尾的。UDP继承了IP的特性，基于数据报的，一个个发，一个个收；
- TCP是可以有拥堵控制的，可以根据网络环境调整自己的行为；UDP就是应用让我发，我就发，管它洪水滔天；
- TCP是一个有状态的服务，通俗的讲就是有脑子的，可以精确的记着，自己发送了没有，接收到没有，发送到哪个了，应该接收到哪个了，错一点儿都不行；UDP其实是一个无状态服务，无脑子，天真无邪的发出去就发出去呗

![img](https://i.loli.net/2021/04/03/jwfA4aPSZvJR2ui.jpg)

![image-20210406094825998](https://i.loli.net/2021/04/06/5q6aFOWMDrkN3Yf.png)

### wireshark抓包分析

![image-20200815065046409](https://tva1.sinaimg.cn/large/007S8ZIlly1ghr442r7f5j310g0u0n9j.jpg)

**Wireshark 抓包遇到 you don’t have permission to capture on that device mac 错误的解决方案**

~~~c
cd /dev
sudo chown AliGht:admin bp*
~~~

**常见的过滤写法**

基本语法：语法：<Protocol> <Direction> <Host(s)> < Value> < Logical Operations> <Other expression>

~~~c
ip.addr == 192.168.5.1 and  !ssdp and !dns
ip.addr == 192.168.2.11  and tcp.port == 3306 and !ssl
tcp.port == 80 and ip.dst == 192.168.5.5 and ip.src == 192.168.2.100
tcp.dstport == 80 or tcp.srcport == 80
http.request.method=="GET"
http.request.method=="POST"
ip.src==192.168.5.5 and http
udp.port == 53 
dns or ssdp
    
host 192.168.5.231 and port 80 and http //只捕获主机192.168.5.231 的http流量
port 80 and http//捕获所有经过该接口的http流量    
host 192.168.5.231 //捕获源目主机均为192.168.5.231
net 192.168.5.0/24 //捕获网段为d192.168.5的所有主机的所有流量
    
~~~

https://www.wireshark.org/docs/wsug_html/#ChUseFilterToolbarSection



### Java网络编程

### 网络模型

- BIO

BIO 就是传统的 [java.io](http://java.io/) 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。

- NIO

NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、**同步非阻塞 **IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。

- AIO 

AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以叫它 AIO（Asynchronous IO），**异步 IO **是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。

###同步/异步、阻塞/非堵塞

![image-20200815224648226](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsg7gsqt5j30u011egwy.jpg)

**阻塞式 I/O**：应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。

~~~C
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
~~~

![img](https://i.loli.net/2021/04/03/LYwTOWac1mg3k2t.png)

**非阻塞式 I/O**:应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。

![img](https://i.loli.net/2021/04/03/RzNfhmqavHC17bX.png)

** I/O 复用**:使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。

如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

![img](https://i.loli.net/2021/04/03/wzCQ8G4Z21kRbYS.png)



实战1:通读全部的Java网络编程的API，最好是BIO。

NIO的本质：nio通过selector可以使用一个线程去管理多个socket句柄，说是管理也不太合适，nio是采用的事件驱动模型，selector负责的是监控各个连接句柄的状态，不是去轮询每个句柄，而是在数据就绪后，将消息通知给selector，而具体的socket句柄管理则是采用多路复用的模型，交由操作系统来完成。selector充当的是一个消息的监听者，负责监听channel在其注册的事件，这样就可以通过一个线程完成了大量连接的管理，当注册的事件发生后，再调用相应线程进行处理。这样就不需要为每个连接都使用一个线程去维持长连接，减少了长连接的开销，同时减少了上下文的切换提高了系统的吞吐量。

**Linux中socket的问题**

利用本地的Socket来把玩TCP的协议，三次握手和四次挥手。

重点记忆：

- 当客户端调用 connect() 函数后，TCP协议会组建一个数据包，并设置 SYN 标志位，表示该数据包是用来建立同步连接的。同时生成一个随机数字 ，填充“序号（Seq）”字段，表示该数据包的序号。完成这些工作，开始向服务器端发送数据包，客户端就进入了SYN-SEND状态。
- 服务器端收到数据包，检测到已经设置了 SYN 标志位，就知道这是客户端发来的建立连接的“请求包”。服务器端也会组建一个数据包，并设置 SYN 和 ACK 标志位，SYN 表示该数据包用来建立连接，ACK 用来确认收到了刚才客户端发送的数据包。
- 客户端收到数据包，检测到已经设置了 SYN 和 ACK 标志位，就知道这是服务器发来的“确认包”。客户端会检测“确认号（Ack）”字段，看它的值是否为 1000+1，如果是就说明连接建立成功。

相关代码展示:

~~~c
#include "MyServer.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
int main(){
    //创建套接字
    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    //将套接字和IP、端口绑定
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
    serv_addr.sin_family = AF_INET;  //使用IPv4地址
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址
    serv_addr.sin_port = htons(1234);  //端口
    bind(serv_sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));
    //进入监听状态，等待用户发起请求
    listen(serv_sock, 20);
    //接收客户端请求
    struct sockaddr_in clnt_addr;
    socklen_t clnt_addr_size = sizeof(clnt_addr);
    //阻塞
    int clnt_sock = accept(serv_sock, (struct sockaddr*)&clnt_addr, &clnt_addr_size);
    //向客户端发送数据
    char str[] = "Hello World!";
    write(clnt_sock, str, sizeof(str));

    //关闭套接字
    close(clnt_sock);
    close(serv_sock);
    return 0;
}
~~~

~~~c
int main(){
    //创建套接字
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    //向服务器（特定的IP和端口）发起请求
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));  //每个字节都用0填充
    serv_addr.sin_family = AF_INET;  //使用IPv4地址
    serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  //具体的IP地址
    serv_addr.sin_port = htons(1234);  //端口
    connect(sock, (struct sockaddr*)&serv_addr, sizeof(serv_addr));

    //读取服务器传回的数据
    char buffer[40];
    read(sock, buffer, sizeof(buffer)-1);

    printf("Message form server: %s\n", buffer);

    //关闭套接字
    close(sock);
    return 0;
}
~~~

### Linux 网络核心知识总结

### 相关重点知识复习

- 用户空间和内核态的复习
- 进程切换、阻塞（阻塞状态是不占用CPU资源的）
- 文件描述符
- 缓存IO（数据需要多次拷贝）
- BlockingIO VS NonBlockingIO（核心在于用户进程需不需要不断的主动询问内核进程是否可以使用）

#### IO多路复用技术

Tips：I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

![image-20200816110620032](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsh48zcibj313o0u0q6d.jpg)

源码分析：

![image-20200816111223380](https://tva1.sinaimg.cn/large/007S8ZIlly1ghshajqcajj31gm0u014b.jpg)

~~~c
int do_select(int n, fd_set_bits *fds, struct timespec *end_time)
{
    // …
    for (;;) {
        // …
        for (i = 0; i < n; ++rinp, ++routp, ++rexp) {
            // …
            struct fd f;
            f = fdget(i);
            if (f.file) {
                const struct file_operations *f_op;
                f_op = f.file->f_op;
                mask = DEFAULT_POLLMASK;
                if (f_op->poll) {
                    wait_key_set(wait, in, out,
                             bit, busy_flag);
                    // 对每个fd进行I/O事件检测
                    mask = (*f_op->poll)(f.file, wait);
                }
                fdput(f);
                // …
            }
        }
        // 退出循环体
        if (retval || timed_out || signal_pending(current))
            break;
        // 进入休眠
        if (!poll_schedule_timeout(&table, TASK_INTERRUPTIBLE,
                to, slack))
            timed_out = 1;
    }
}
~~~

`(*f_op->poll)`会返回当前设备fd的状态（比如是否可读可写），根据这个状态，`do_select()`接着做出不同的动作

- 如果设备fd的状态与主程序的感兴趣的I/O事件匹配，则记录下来，`do_select()`退出循环体，并把结果返回给上层主程序。
- 如果不匹配，`do_select()`发现timeout已经到了或者进程有signal信号打断，也会退出循环，只是返回空的结果给上层应用。

但如果`do_select()`发现当前没有事件发生，又还没到timeout，更没signal打扰，内核会在这个循环体里面永远地轮询下去吗？

`select()`把全部fd检测一轮之后如果没有可用I/O事件，会让当前进程去休眠一段时间，等待fd设备或定时器来唤醒自己，然后再继续循环体看看哪些fd可用，以此提高效率。重点在poll_schedule_timeout（）函数中。

**驱动层面**：

![image-20200816112314764](https://tva1.sinaimg.cn/large/007S8ZIlly1ghshlvci5cj31a30u0dvs.jpg)

每一个文件file结构体中都含有file_operations这个结构体。linux内核不知道每个具体的文件设备是怎么操作的（怎么打开，怎么读写），所以需要通过每个设备的驱动函数来回掉使用。

~~~c
unsigned int (*poll) (struct file *, struct poll_table_struct *);

#For every file descriptor, it calls that fd’s poll() method, which will add the #caller to that fd’s wait queue, and return which events (readable, writeable, #exception) currently apply to that fd.
~~~

对于应用层的开发同学，重点是什么？？

理解select的模型这么处理多FD的。重点看代码，然后思考select的问题和优点：

**Select编程模型的抽象总结：**

~~~c
int main() {


  fd_set read_fs, write_fs;
  struct timeval timeout;
  int max_sd = 0;  // 用于记录最大的fd，在轮询中时刻更新即可
  
  /*
   * 这里进行一些初始化的设置，
   * 包括socket建立，地址的设置等,
   * 同时记得初始化max_sd
   */

  // 初始化比特位
  FD_ZERO(&read_fs);
  FD_ZERO(&write_fs);

  int rc = 0;
  int desc_ready = 0; // 记录就绪的事件，可以减少遍历的次数
  while (1) {
    // 这里进行阻塞
    rc = select(max_sd + 1, &read_fd, &write_fd, NULL, &timeout);
    if (rc < 0) {
      // 这里进行错误处理机制
    }
    if (rc == 0) {
      // 这里进行超时处理机制
    }

    desc_ready = rc;
    // 遍历所有的比特位，轮询事件
    for (int i = 0; i <= max_sd && desc_ready; ++i) {
      if (FD_ISSET(i, &read_fd)) {
        --desc_ready;
        // 这里处理read事件，别忘了更新max_sd
      }
      if (FD_ISSET(i, &write_fd)) {
        // 这里处理write事件，别忘了更新max_sd
      }
    }
  }
}
~~~

很明显，可以看出来在底层主要是依赖bit位的处理来达到FD的处理，FD就是通知了OS层面可以对数据进行处理。

#### TCP粘包问题

![image-20200816143620355](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsn6stgcej314c0m2gw7.jpg)

- 注意UDP不存在粘包、分包的问题，因为在协议头重定义了length（16bit）。
- TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界。
- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包；待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包；要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包；接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

如何解决？思路是增加上层业务协议边界。详细参见代码

### 长链接在日常业务中的思考和心得

https://github.com/Tencent/mars/blob/master/mars/stn/src/smart_heartbeat.cc

https://tech.meituan.com/2017/03/17/shark-sdk.html

https://blog.csdn.net/carson_ho/article/details/79522975

http://www.52im.net/thread-52-1-1.html

协议需要支持什么特性？

- 非常精简的固定头部
- 支持二进制序列化(TCP)以及文本序列化(WebSockets), 文本序列化支持消息分包传送(传递二进制数据)
- 与IP协议掩码类似的上层路由控制
- 负载编码格式对协议透明
- 心跳检测、断点重联
- 需要有丰富的消息类型（心跳, 请求, 通知, 回复）
- 返回状态码控制

移动端：

- 进程保活（JOB）
- 进程控制（多进程）+AIDL
-  编码（维护 、lib、gradle插件、aar 解耦、技巧问题（模式+编码规范+数据结构））
- 业务上的思考（心跳 怎么发？内容  超时）

### HttpDNS&DNSProtocal

这里重点实现C语言底层实现DNS协议的网络解析过程，不涉及Android业务层面的开发。

弱网监测、切换机制、DNS上层

![image-20200816165907493](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsrbc5ew5j31dn0bkdi5.jpg)

**算法实现过程**：详细参见代码和wireshark抓包。

### epoll机制精要

相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。

![image-20200821211934065](https://tva1.sinaimg.cn/large/007S8ZIlly1ghyqxw93q3j313e0u0hcn.jpg)

~~~c
epfd = int epoll_create(int size); //创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大在使用完epoll的时候一定要关闭。


int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //epoll的事件注册函数，

EPOLL_CTL_ADD：注册新的fd到epfd中；
EPOLL_CTL_MOD：修改已经注册的fd的监听事件；
EPOLL_CTL_DEL：从epfd中删除一个fd；

//第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事。

typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;

struct epoll_event {
    __uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
};

EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里；


int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); //
~~~

实战代码。

###网络通信经典协议（组播、广播）

![image-20200821214929952](https://tva1.sinaimg.cn/large/007S8ZIlly1ghyrszta1mj31dk0pfnkd.jpg)

参见代码。

重点：广播服务端：使用广播地址发送到目标客户端的端口上，添加广播权限。客户端只接收数据，绑定端口。不发送数据

~~~c
struct ip_mreqn
{
    // 组播组的IP地址.
     struct in_addr imr_multiaddr; 
      // 本地某一网络设备接口的IP地址。
     struct in_addr imr_interface;   
    int   imr_ifindex;   // 网卡编号
};

struct in_addr 
{
    in_addr_t s_addr;
};

224.0.0.0～224.0.0.255        为预留的组播地址（永久组地址），地址224.0.0.0保留不做分配，其它地址供路由协议使用；
224.0.1.0～224.0.1.255        是公用组播地址，可以用于Internet；欲使用需申请。
224.0.2.0～238.255.255.255    为用户可用的组播地址（临时组地址），全网范围内有效；
239.0.0.0～239.255.255.255    为本地管理组播地址，仅在特定的本地范围内有效。
~~~

组播服务端：使用组播地址，绑定组播端口，客户端需要加入组播组。

### Libevent

https://libevent.org/

https://github.com/libevent/libevent

- 基于事件通知机制的库
- 跨操作系统的库
- libevent 库实际上没有更换select()、poll()或其他机制的基础,只是封装了一层

#### 编译问题

- autoreconf  -ivf 
- Make&make install
- ./configure --prefix=/opt/libevent --disable-openssl

#### 事件驱动设计模式(Reactor模式)

和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，Reactor**逆置**了事件处理流程，应用程序需要提供相应的接口并注册到Reactor上，如果相应的时间发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。

- Reactor

Reactor是Reactor模式中最为关键的角色，它是该模式最终向用户提供接口的类。

- EventHandler

事件处理器，可以根据事件的不同状态创建处理不同状态的处理器；

- Handle

可以理解为事件，在网络编程中就是一个Socket，在数据库操作中就是一个DBConnection；

- InitiationDispatcher

用于管理EventHandler，分发event的容器，也是一个事件处理调度器。比如在Tomcat的Dispatcher就是一个很好的实现，用于接收到网络请求后进行第一步的任务分发，分发给相应的处理器去异步处理，来保证吞吐量；

- Demultiplexer

阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。

![image-20200823134711171](https://tva1.sinaimg.cn/large/007S8ZIlly1gi0p3temgnj30v40m017c.jpg)

#### Reactor思考

-  解决多线程 多任务 服务器编程。解决以前的阻塞性能差的问题。（以前是线程池的做法）

- 基于Reactor模式实现的服务器方案，会有一个Dispatcher先接收event，然后快速分发给相应的耗时eventHandler处理器去处理，这样就不会阻塞请求的接收。
- Reactor模式和生产者消费者模式最大的区别在于，生产者消费者模式是基于队列的实现，能够解决生产端和消费端处理速度不匹配的问题，queue可以基于Java Queue或者基于现有的MQ（Kafka、RQ）产品来实现；而Reactor模式是基于事件驱动模型，当接收到请求后会将请求封装成事件，并将事件分发给相应处理事件的Handler，handler处理完成后将事件状态修改为下一个状态，再由Reactor将事件分发给能够处理下一个状态的handler进行处理。（拦截器）
- Reactor模式的优点很明显，解耦、提升复用性、模块化、可移植性、事件驱动、细力度的并发控制等。缺点也是明显的，难度大，架构复杂，不易理解。

具体参见代码。重在理解

###HTTP

http://web-sniffer.net/rfc/rfc2616.html

https://http2.github.io/

学习网络框架要和协议本身进行结合。我们首先回顾一些基础的HTTP协议知识。然后我会带大家实现一个网络请求框架简易版本，让大家感受下造轮子的方式和一些基础的要求。

- 每次连接只处理一个请求.服务器处理完客户端的请求,然后响应,并收到应答之后,就断开连接.这种方式可以节省传输时间。（无链接）
- HTTP协议是无状态协议.无状态是指协议 对于事务处理没有记忆能力。（Cookie和Session技术用于服务端的编程）

![image-20200829105307717](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7hto2zegj30xq0k2dwq.jpg)

*常见的报文头的属性*：

| 字段              | 说明                                  | 示例                                                         |
| :---------------- | :------------------------------------ | :----------------------------------------------------------- |
| Accept            | 可接收的响应内容类型                  | Accept:text/plain (文本类型)                                 |
| Accept-Charset    | 可接收的字符集                        | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 可接受的响应内容的编码方式            | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 可接受的响应内容语言列表              | Accept-Language: en-US                                       |
| Accept-Datetime   | 可接受的按照时间来表示的响应内容版本  | Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT               |
| Authorization     | HTTP协议中需要认证资源的认证信息      | Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==            |
| Cache-Control     | 请求/回复中的,是否使用缓存机制        | Cache-Control: no-cache                                      |
| Connection        | 客户端想要优先使用的连接类型          | Connection: keep-alive Connection: Upgrade                   |
| Content-Length    | 以8进制表示的请求体的长度             | Content-Length: 348                                          |
| Content-Type      | 请求体的MIME类型                      | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                | Date: Dec, 26 Dec 2015 17:30:00 GMT                          |
| Expect            | 表示客户端要求服务器做出特定的行为    | Expect: 100-continue                                         |
| From              | 发起此请求的用户的邮件地址            | From: user@itbilu.com                                        |
| Host              | 服务器域名和端口号,默认端口可省略     | Host: [www.itbilu.com:80](http://www.itbilu.com/) or [www.itbilu.com](http://www.itbilu.com/) |
| If-Match          | 主要用于PUT,实体匹配才可以操作        | If-Match: "9jd00cdj34pss9ejqiw39d82f20d0ikd"                 |
| If-Modified-Since | 资源未被修改的情况下返回304未修改     | If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT             |
| User-Agent        | 浏览器的身份标识字符串                | User-Agent: Mozilla/                                         |
| Upgrade           | 要求服务器升级到一个高版本协议        | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               |
| Via               | 告诉服务器,这个请求是由哪个代理发出的 | Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)               |
| Referer           | 表示跳转到当前页面的之前的页面        | Referer: http://itbilu.com/nodejs                            |
| Origin            | 发起一个针对跨域资源共享的请求        | Origin: [http://www.itbilu.com](http://www.itbilu.com/)      |

![image-20200829110330330](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7i3dm48zj31n00qstus.jpg)



**Keep-Alive**

![image-20200829110024552](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7i078twvj31ka0u01kx.jpg)

HTTP的Keep-Alive与TCP的Keep Alive，有些不同，两者意图不一样。

- HTTP的Keep-Alive主要是 TCP连接复用，避免简历过多的TCP连接。

- TCP的Keep Alive的意图是在于保持TCP连接的存活，就是发送心跳包。隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。
  

**使用HTTP建立长连接**：

当需要建立 HTTP 长连接时，HTTP 请求头将包含如下内容：
`Connection: Keep-Alive`
如果服务端同意建立长连接，HTTP 响应头也将包含如下内容：
`Connection: Keep-Alive`
当需要关闭连接时，HTTP 头中会包含如下内容：
`Connection: Close`



总结：

keep_alive :TCP启动慢，性能低，打开一条链接通道。超时时间一般服务器配置。

长链接：心跳消息 keep-Alive 能不能做心跳？可以 但是没人这么干

底层：OS 10次 2小时。服务器的标高 爆了 连接是好的但是业务死掉了 假死

失去作用 （网线拔掉 peer error Socket代理）自己涉及

检测时间？间隔？额外信息



### HTTP/2.0

![image-20200829110544010](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7i5t3qtej31z80qq44w.jpg)

https://http2.akamai.com/demo

https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn

![image-20200829110707777](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7i78q7jjj317s0u0nnc.jpg)

**新特性介绍：**

- **二进制分帧层**

 ![image-20200829111604571](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7igeg8qpj316w0n0jvj.jpg)

![image-20200829111957585](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7ikgkzyrj31660ccaaz.jpg)

- 16位的长度前缀意味着一帧大约可以携带64KB数据，不包括8字节首部
- 8位的类型字段决定如何解释帧其余部分的内容
- 8位的标志字段允许不同的帧类型定义特定于帧的消息标志
- 1位的保留字段始终置为0
- 31位的流标识符唯一标识`HTTP 2.0`的流

**HTTP 2.0规定了以下的帧类型：**

- **DATA**，用于传输`HTTP`消息体
- **HEADERS**，用于传输关于流的额外的首部字段（`Header`）
- **PRIORITY**，用于指定或者重新指定流的优先级
- **RST_STREAM**，用于通知流的非正常终止
- **SETTINGS**，用于通知两端通信方式的配置数据
- **PUSH_PROMISE**，用于发出创建流和服务器引用资源的要约
- **PING**，用于计算往返时间，执行“活性”检查
- **GOAWAY**，用于通知客户端/服务器停止在当前连接中创建流
- **WINDOW_UPDATE**，用于针对个别流或者个别连接实现流量控制
- **CONTINUATION**，用于继续一系列首部块片段



**多路复用 **

http/1中的每个请求都会建立一个单独的连接，除了在每次建立连接过程中的三次握手之外，还存在TCP的慢启动导致的传输速度低。其实大部分的http请求传送的数据都很小，就导致每一次请求基本上都没有达到正常的传输速度。

在http1.1中默认开启keep-alive，解决了上面说到的问题，但是http的传输形式是一问一答的形式，一个请求对应一个响应（http2中已经不成立，一个请求可以有多个响应，server push），在keep-alive中，必须等下上一个请求接受才能发起下一个请求，所以会收到前面请求的阻塞。

http2的传输是基于二进制帧的。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。这样就解决了阻塞的问题，同时也提高了网络速度的利用率。

![image-20200829113332252](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7iymcuggj30wg0u0n7z.jpg)

[rfc7540: HTTP2 Multiplexing](https://tools.ietf.org/html/rfc7540#page-15)中对Multiplexing的说明

```c
Streams and Multiplexing

   A "stream" is an independent, bidirectional sequence of frames
   exchanged between the client and server within an HTTP/2 connection.
   Streams have several important characteristics:

   o  A single HTTP/2 connection can contain multiple concurrently open
      streams, with either endpoint interleaving frames from multiple
      streams.

   o  Streams can be established and used unilaterally or shared by
      either the client or server.

   o  Streams can be closed by either endpoint.

   o  The order in which frames are sent on a stream is significant.
      Recipients process frames in the order they are received.  In
      particular, the order of HEADERS and DATA frames is semantically
      significant.

   o  Streams are identified by an integer.  Stream identifiers are
      assigned to streams by the endpoint initiating the stream.
```

在OKHTTP中的表现：

![image-20200829190102940](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7vw78so9j31ok0u07er.jpg)

![image-20200829190302740](https://tva1.sinaimg.cn/large/007S8ZIlly1gi7vy9hynxj31d40p80yt.jpg)

ReaderRunnable主要的作用是读取从服务器返回的各种类型数据。包括*HPACKhttps://github.com/twitter/hpack等。

###网络框架封装心得

时序、结构、套路等。具体参见直播课。自己如何通过网络开源项目进行抽取，理解，自己实现一套基于开源项目的简单版本的框架。

### WebSocket协议总结

https://tools.ietf.org/html/rfc6455

WebSocket是基于TCP的应用层协议，用于在C/S架构的应用中实现**双向通信**。虽然WebSocket协议在建立连接时会使用HTTP协议，但这并不意味着WebSocket协议是基于HTTP协议实现的。

```c
The WebSocket Protocol enables two-way communication between a client running untrusted code in a controlled environment to a remote host
that has opted-in to communications from that code.  The security
model used for this is the origin-based security model commonly used
by web browsers.  The protocol consists of an opening handshake
followed by basic message framing, layered over TCP.  The goal of
this technology is to provide a mechanism for browser-based
applications that need two-way communication with servers that does
not rely on opening multiple HTTP connections (e.g., using
XMLHttpRequest or <iframe>s and long polling).
```

**WebSocket与Http的区别**：

- WebSocket是双向通信模式，客户端与服务器之间只有在握手阶段是使用HTTP协议的“请求-响应”模式交互，而一旦连接建立之后的通信则使用双向模式交互，不论是客户端还是服务端都可以随时将数据发送给对方；而HTTP协议则至始至终都采用“请求-响应”模式进行通信。也正因为如此，HTTP协议的通信效率没有WebSocket高。
- 协议格式不同。对于HTTP协议来讲，一个数据包就是一条完整的消息；而WebSocket客户端与服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。

~~~
0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+

HTTP 请求：
Request-LineCRLF
general-headerCRLF
request-headerCRLF
entity-headerCRLF
CRLF
[ message-body ]

HTTP 响应：
Status-LineCRLF
general-headerCRLF
response-headerCRLF
entity-headerCRLF
CRLF
[ message-body ]
~~~

#### WebSocket使用场景

- **客户端定时查询**

- **长轮训机制**

社交聊天、弹幕、多玩家游戏、协同编辑、股票基金实时报价、体育实况更新、视频会议/聊天、基于位置的应用、在线教育、智能家居等需要高实时的场景。WebSocket对上面2种场景的改写。支持客户端和服务器端的双向通信，而且协议的头部又没有HTTP的Header那么大，可以节约流量。

https://cloud.tencent.com/developer/article/1004362 参考下

#### WebSocket和Socket的区别与联系

Socket 其实并不是一个协议。它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。(ip+port) / 进程

Socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄。网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket，一个Socket由一个IP地址和一个端口号唯一确定。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。

Socket在通讯过程中，服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，这样一个连接就建立起来了。客户端和服务端也都可以**相互发送消息**与对方进行通讯，直到双方连接断开。

#### 协议分析

http://www.websocket-test.com/

![image-20200903225236733](https://tva1.sinaimg.cn/large/007S8ZIlly1giduoqalrtj31l00u04cu.jpg)

![image-20200903225558499](https://tva1.sinaimg.cn/large/007S8ZIlly1gidusae2opj31pq0u0k63.jpg)

**各字段的解释：**

FIN                  1bit 表示信息是否结束, 如果为1则该消息为消息尾部,如果为零则还有后续数据包; 

RSV 1-3         1bit 备用字段 默认都为 0

Opcode          4bit 消息类型，消息类型暂定有15种,其中有几种是预留设置。

Mask               1bit 掩码，是否加密数据，(客户端发送给后端时，mask必须为1，否则close连接；服务器发送给前端时，mask必须为0，否则断开连接)

Payload len    7bit 数据的长度，当这个7 bit的数据 == 126 时，后面的2 个字节表示数据长度，当它 == 127 时，后面的 8 个字节表示数据长度

Masking-key   0/32 bit 掩码值( Mask为1时才有)

Payload data  长度为Payload len的数据，如果有掩码 需要用mask-Key来异或 才能得到。

![image-20200903230245777](https://tva1.sinaimg.cn/large/007S8ZIlly1giduz90g0zj30v20cktc3.jpg)

Masking-key ，0或者4个字节，当MASK位为1时，4个字节，否则0个字节。如果MASK值为1，则发出去的数据需要经过加密处理，加密流程如下：

~~~java
void mask(byte[] original, byte[] maskKey) {
   for (int i = 0; i < original.length; i++) {
        original[i] = (byte) (original[i] ^ maskKey[i % 4]);
   }
}
~~~

### OKhttp使用WebSocketAPI

https://square.github.io/okhttp/4.x/okhttp/okhttp3/-web-socket/

基本API：

~~~kotlin
fun connectionWebSockt(hostName:String,port:Int){
  val httpClient = OkHttpClient.Builder()
      .pingInterval(40, TimeUnit.SECONDS) // 设置 PING 帧发送间隔
      .build()
  val webSocketUrl = "ws://${hostName}:${port}"
  val request = Request.Builder()
      .url(webSocketUrl)
      .build()
  httpClient.newWebSocket(request, object:WebSocketListener(){
    // ...
  })
}
~~~

~~~kotlin
var mWebSocket : WebSocket? = null
fun connectionWebSockt(hostName:String,port:Int){
  // ...
  httpClient.newWebSocket(request, object:WebSocketListener(){
    override fun onOpen(webSocket: WebSocket, response: Response) {
      super.onOpen(webSocket, response)
      // WebSocket 连接建立
      mWebSocket = webSocket
    }

    override fun onMessage(webSocket: WebSocket, text: String) {
      super.onMessage(webSocket, text)
      // 收到服务端发送来的 String 类型消息
    }

    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {
      super.onClosing(webSocket, code, reason)
      // 收到服务端发来的 CLOSE 帧消息，准备关闭连接
    }

    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {
      super.onClosed(webSocket, code, reason)
      // WebSocket 连接关闭
    }

    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
      super.onFailure(webSocket, t, response)
      // 出错了
    }
  })
}
~~~

难点：

**鉴权：**任何的业务都需要鉴权，IM等等吧。

- 避免服务端启动 WebSocket 的连接服务后，任谁都可以连接，这肯定会引发一些安全问题。
- 服务端还需要将 WebSocket 的连接实体与一个真实的用户对应起来，否者业务无法保证了。类似微信登陆，把微信登录拿到的session数据和我们自己的服务器进行关联，把数据插入到自己的后台的sql中。

解决办法：

- wss://192.168.77.88:443?uid=xxx&token=xxx

- final Request request = originalRequest.newBuilder()
  .header("Upgrade", "websocket")
  
  .header("uid=xxx", "***").header("token", "***").header("Connection", "Upgrade")
  .header("Sec-WebSocket-Key", key)
  .header("Sec-WebSocket-Version", "13")
  
  .build();

**WebSocket 保活**：

~~~kotlin
val httpClient = OkHttpClient.Builder()
      .pingInterval(40, TimeUnit.SECONDS) // 设置 PING 帧发送间隔
      .build()
~~~

作业&练习：直播定

### Quic

参考资料：https://github.com/evansun922/nginx-quic

https://src.chromium.org/viewvc/chrome/trunk/src/net/quic/

https://zhuanlan.zhihu.com/p/37919534

Android&IOS常用使用的库：

https://developer.android.com/guide/topics/connectivity/cronet

https://developer.android.com/guide/topics/connectivity/cronet/reference/org/chromium/net/package-summary（API）

https://github.com/bgylde/chromium-cornet



https://www.chromium.org/developers/how-tos/get-the-code

重点总结：

- chromium源码环境；
- 提前配置好相关环境，安装好相关依赖；
- 在linux环境下完成对Android库的编译，在macos环境下会直接编译为ios平台库；

**操作指南**：

~~~c
//depot_tools 添加到环境目录
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 
mkdir chromium
fetch --no-history --nohooks  android      # fetch --no-history  ios

//如果失败
gclient sync 

//指定版本
git fetch origin 75.0.3770.142
git checkout -b chromium-ios-75.0.3770.142 FETCH_HEAD
gclient sync --with_branch_heads



//编译 python 2.7.5，及 openjdk 8，较高版本由于接口不兼容需避免使用
# 生成 ninja 文件
./components/cronet/tools/cr_cronet.py gn --out_dir=out/Cronet    
# 输入 ninja 文件执行编译，必须指定为 cronet_package
ninja -C out/Cronet cronet_package  #–release  

~~~

API使用？：

- 创建CronetEngine，类似Okhttp的Client。
- 创建自己的线程池，Cronet的网络请求都会在线程池中，避免主线程阻塞。
- 实现回调UrlRequest.Callback，在UrlRequest调用start以后，网络请求开始，之后产生请求回调。

#### 开源 QUIC 的实现

- quiche：这个是用 `Rust` 做的库，通过   [Nginx](https://www.sojson.com/tag_nginx.html)   调用。google 自己的库也叫 quiche，C++写的。
- ATS：Apache Traffic Server
-  golang：Caddy；
- python+C，aioquic
- 微软msquic

https://github.com/square/okhttp/issues/907 

https://halfrost.com/quic_start/

#### Quic Protocol 

https://www.ietf.org/proceedings/96/slides/slides-96-quic-5.pdf

chrome-extension://ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fpic.huodongjia.com%2Fganhuodocs%2F2018-04-28%2F1524906080.9.pdf

https://datatracker.ietf.org/doc/draft-ietf-quic-transport/10/ 

**测试**：

google 浏览器打开quic支持。chrome://flags/。chrome://net-export/

![image-20200906135323464](https://tva1.sinaimg.cn/large/007S8ZIlly1gigvyjwpk2j31ez0u0qgx.jpg)



作业布置：直播课



本周作业：

~~~c
1.websocket 借助okhttp和我们的服务器，音视频+图片，目的：协议的理解，看字段，掌握okhhtp的基础API（关注的焦点是流程）PONG
2.参考Okhttp的框架源码（websocket，接口，client），自己基于google的框架封装自己的quicLib库。
3.quic server搭建
~~~

### HttpsVSHttp

#### 加密

**对称加密：**

- 加密方和解密方使用同一个密钥。
- 加密解密的速度比较快，适合数据比较长时的使用。
- 密钥传输的过程不安全，且容易被破解，密钥管理也比较麻烦。
- 加密算法：DES（Data Encryption Standard）、3DES、AES（Advanced Encryption Standard，支持128、192、256、512位密钥的加密）、Blowfish。
- 加密工具：openssl、gpg(pgp工具)

加密：明文+加密算法+私钥 == 密文

**非对称加密（公钥加密）：**

- 每个用户拥用一对密钥加密：公钥和私钥。
- 公钥加密，私钥解密；私钥加密，公钥解密。
- 公钥传输的过程不安全，易被窃取和替换。
- 由于公钥使用的密钥长度非常长，所以公钥加密速度非常慢，一般不使用其去加密。
- 某一个用户用其私钥加密，其他用户用其公钥解密，实现数字签名的作用。
- 公钥加密的另一个作用是实现密钥交换。
- 加密和签名算法：RSA、ELGamal。
- 公钥签名算法：DSA。
- 加密工具：gpg、openssl

加密：明文+加密算法+私钥 == 密文

思考？为什么需要非对称加密算法？解决什么问题？

**密钥交换**：

服务器拥有私钥和公钥，然后给每个客户端发送公钥，服务器把自己公钥以明文形式的发给客户端；然后客户端自己生成一个密钥，再用公钥加密这个密钥，这个加密的结果，只有私钥能解密，而私钥只在服务器端，也就是说，被非对称加密的密钥只能由服务器端解密；这样就完成了密钥交换，而且密钥不用以明文形式传输，其安全性是基于非对称加密算法的。

#### RSA

http://zh.wikipedia.org/zh-cn/RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95

~~~java
import com.sun.org.apache.xml.internal.security.utils.Base64;

import javax.crypto.Cipher;
import java.security.*;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.HashMap;
import java.util.Map;

public class RSA {
    private static Map<Integer, String> keyMap = new HashMap<Integer, String>();  //用于封装随机产生的公钥与私钥
    public static void main(String[] args) throws Exception {
        //生成公钥和私钥
        genKeyPair();
        //加密字符串
        String message = "df723820";
        System.out.println("随机生成的公钥为:" + keyMap.get(0));
        System.out.println("随机生成的私钥为:" + keyMap.get(1));
        String messageEn = encrypt(message,keyMap.get(0));
        System.out.println(message + "\t加密后的字符串为:" + messageEn);
        String messageDe = decrypt(messageEn,keyMap.get(1));
        System.out.println("还原后的字符串为:" + messageDe);
    }

    /**
     * 随机生成密钥对
     * @throws NoSuchAlgorithmException
     */
    public static void genKeyPair() throws NoSuchAlgorithmException {
        // KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象
        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");
        // 初始化密钥对生成器，密钥大小为96-1024位
        keyPairGen.initialize(1024,new SecureRandom());
        // 生成一个密钥对，保存在keyPair中
        KeyPair keyPair = keyPairGen.generateKeyPair();
        RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();   // 得到私钥
        RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();  // 得到公钥
        String publicKeyString = new String(Base64.encode(publicKey.getEncoded()));
        // 得到私钥字符串
        String privateKeyString = new String(Base64.encode((privateKey.getEncoded())));
        // 将公钥和私钥保存到Map
        keyMap.put(0,publicKeyString);  //0表示公钥
        keyMap.put(1,privateKeyString);  //1表示私钥
    }
    /**
     * RSA公钥加密
     *
     * @param str
     *            加密字符串
     * @param publicKey
     *            公钥
     * @return 密文
     * @throws Exception
     *             加密过程中的异常信息
     */
    public static String encrypt( String str, String publicKey ) throws Exception{
        //base64编码的公钥
        byte[] decoded = Base64.decode(publicKey);
        RSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance("RSA").generatePublic(new X509EncodedKeySpec(decoded));
        //RSA加密
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        String outStr = Base64.encode(cipher.doFinal(str.getBytes("UTF-8")));
        return outStr;
    }

    /**
     * RSA私钥解密
     *
     * @param str
     *            加密字符串
     * @param privateKey
     *            私钥
     * @return 铭文
     * @throws Exception
     *             解密过程中的异常信息
     */
    public static String decrypt(String str, String privateKey) throws Exception{
        //64位解码加密后的字符串
        byte[] inputByte = Base64.decode(str.getBytes("UTF-8"));
        //base64编码的私钥
        byte[] decoded = Base64.decode(privateKey);
        RSAPrivateKey priKey = (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(new PKCS8EncodedKeySpec(decoded));
        //RSA解密
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, priKey);
        String outStr = new String(cipher.doFinal(inputByte));
        return outStr;
    }
}
~~~

| 步骤 | 说明         | 描述              | 备注                                     |
| ---- | ------------ | ----------------- | ---------------------------------------- |
| 1    | 找出质数     | P 、Q             | -                                        |
| 2    | 计算公共模数 | N = P * Q         | -                                        |
| 3    | 欧拉函数     | φ(N) = (P-1)(Q-1) | -                                        |
| 4    | 计算公钥E    | 1 < E < φ(N)      | E的取值必须是整数 E 和 φ(N) 必须是互质数 |
| 5    | 计算私钥D    | E * D % φ(N) = 1  | -                                        |
| 6    | 加密         | C ＝ M E mod N    | C：密文 M：明文                          |
| 7    | 解密         | M ＝C D mod N     | C：密文 M：明文                          |

公钥＝(E , N)
私钥＝(D, N) 

对外，只暴露公钥。

**数学理解**

P=17，Q=19 N=17*19=323

L ＝ lcm（p－1， q－1）＝ lcm(16，18） ＝ 144  144是16和18的最小公倍数

E = 5 （1 < E < 144，gcd（E，144） ＝ 1  E和144互为质数）

**公钥=(E，N）＝ （5，323）**

D = 29 （1 < D < L，E＊D mod L ＝ 1  【5＊29 mod 144 ＝ 145 mod 144 ＝ 1】 ）

**私钥＝（D，N）＝（29，323）**

假如明文为123：

密文＝明文 ^ E mod N ＝123 ^5 mod 323 = 225

明文＝密文 ^ D mod N ＝ 225 ^ {29} mod 323 = 123

####DH密钥协商算法

不要关注算法本身，重点是应用

**参数文件**

~~~c
typedef struct dh_st{
	BIGUNM *p;
	BIGUNM *g;
	BIGUNM *pub_key;
	BIGUNM *priv_key;
}DH;
~~~

![image-20200925154554308](https://tva1.sinaimg.cn/large/007S8ZIlly1gj2xzj02q8j30wy0l01kx.jpg)

Z就是会话密钥，注意这个流程，客户端和server都参与进来了。保证了安全，所以比RSA更加的安全。

JDK的实现：

~~~java
try {
            //1.初始化发送方密钥
            KeyPairGenerator senderKeyPairGenerator = KeyPairGenerator.getInstance("DH");
            senderKeyPairGenerator.initialize(512);
            KeyPair senderKeyPair = senderKeyPairGenerator.generateKeyPair();
            byte[] senderPublicKeyEnc = senderKeyPair.getPublic().getEncoded();//发送方公钥，发送给接收方（网络、文件。。。）

            //2.初始化接收方密钥
            KeyFactory receiverKeyFactory = KeyFactory.getInstance("DH");
            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(senderPublicKeyEnc);
            PublicKey receiverPublicKey = receiverKeyFactory.generatePublic(x509EncodedKeySpec);
            DHParameterSpec dhParameterSpec = ((DHPublicKey)receiverPublicKey).getParams();
            KeyPairGenerator receiverKeyPairGenerator = KeyPairGenerator.getInstance("DH");
            receiverKeyPairGenerator.initialize(dhParameterSpec);
            KeyPair receiverKeypair = receiverKeyPairGenerator.generateKeyPair();
            PrivateKey receiverPrivateKey = receiverKeypair.getPrivate();
            byte[] receiverPublicKeyEnc = receiverKeypair.getPublic().getEncoded();

            //3.密钥构建
            KeyAgreement receiverKeyAgreement = KeyAgreement.getInstance("DH");
            receiverKeyAgreement.init(receiverPrivateKey);
            receiverKeyAgreement.doPhase(receiverPublicKey, true);
            SecretKey receiverDesKey = receiverKeyAgreement.generateSecret("DES");

            KeyFactory senderKeyFactory = KeyFactory.getInstance("DH");
            x509EncodedKeySpec = new X509EncodedKeySpec(receiverPublicKeyEnc);
            PublicKey senderPublicKey = senderKeyFactory.generatePublic(x509EncodedKeySpec);
            KeyAgreement senderKeyAgreement = KeyAgreement.getInstance("DH");
            senderKeyAgreement.init(senderKeyPair.getPrivate());
            senderKeyAgreement.doPhase(senderPublicKey, true);
            SecretKey senderDesKey = senderKeyAgreement.generateSecret("DES");
            if (Objects.equals(receiverDesKey, senderDesKey)) {
                System.out.println("双方密钥相同");
            }

            //4.加密
            Cipher cipher = Cipher.getInstance("DES");
            cipher.init(Cipher.ENCRYPT_MODE, senderDesKey);
            byte[] result = cipher.doFinal(src.getBytes());
            System.out.println("jdk dh encrypt : " + Base64.encode(result));

            //5.解密
            cipher.init(Cipher.DECRYPT_MODE, receiverDesKey);
            result = cipher.doFinal(result);
            System.out.println("jdk dh decrypt : " + new String(result));
        } catch (Exception e) {
            e.printStackTrace();
        }
~~~

### JCE框架

Java Cryptography Extension

Cipher类为加密和解密提供密码功能。它构成了JCE框架的核心(引擎类)。NullCiper是用来验证程序的有效性，并不提供具体的加密和解密实现。

```java
//实例化
getInstance(String transformation)
getInstance(String transformation,Provider provider)
getInstance(String transformation,String provider)

//注意：transFormation的表达形式--"算法/工作模式/填充模式"
Cipher cipher = Cipher.getInstance("AES");
Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

DECRYPT_MODE //解密模式
ENCRYPT_MODE //加密模式
WRAP_MODE //包装操作
UNWRAP_MODE //解包装操作
//初始化
init(int opmode,Key key) //opmode对应上面常量
init(int opmode,Key key,AlgorithmParameters params)
init(int opmode,Key key,AlgorithmParameterSpec params)
init(int opmode,Key key,AlgorithmParameters params,SecureRandom random)
init(int opmode,Key key,AlgorithmParameterSpec params,SecureRandom random)
init(int opmode,Certificate certificate)
init(int opmode,Certificate certificate,SecureRandom random)

//输入给定的字节数组完成更新
update(byte[] input)
update(byte[] input,int off,int len)
//将更新结果输出到参数中
update(byte[] input,int off,int len,byte[] output)
update(byte[] input,int off,int len,byte[] output,int outputoffset)
//使用缓冲的方式
update(ByteBuffer input,ByteBuffer output)

//结束多部分加密和解密操作
doFinal()
...

//包装密钥
wrap(Key key)

//解包装
unwrap(byte[] wrappedKey,String wrappedKeyAlgorithm,int wrappedKeyType)

//wrappedKeyType对应以下常量
PRIVATE_KEY //私钥
PUBLIC_KEY //公钥
SECRET_KEY //秘密密钥

//返回缓冲区中的初始化向量
getIV()

//返回指定转换的最大密钥长度
getMaxAllowedKeyLength(String transformation)

//分组加密中，每一组都有固定的长度，称为块
getBlockSize()

//获取缓冲区字节长度
getOutputSize(int intputLen)

//返回最大参数相关信息
getMaxAllowedParameterSpec(String transformation)

//获取参数
getParameters()

//获取豁免机制对象
getExemptionMechanism()

//获取算法
getAlgorithm()

//获取提供者
getProvider()
```

```java
//包装密钥
KeyGenerator kg = KeyGenerator.getInstance("DES");
SecretKey secretKey = kg.generateKey();
Cipher cipher = Cipher.getInstance(kg.getAlgorithm());
cipher.init(Cipher.WRAP_MODE,secretKey);
byte[] bytes = cipher.wrap(secretKey);

//解包装
Cipher cipher = Cipher.getInstance(kg.getAlgorithm());
cipher.init(Cipher.UNWRAP_MODE,secretKey);
byte[] bytes = cipher.unwrap(bytes,"DES",Cipher.SECRET_KEY);

//加密 此处略去了实例化
cipher.init(Cipher.ENCRYPT_MODE,secretKey);
byte[] input = cipher.doFinal("DES DATA".getBytes());

//解密 此处略去了实例化
cipher.init(Cipher.DECRYPT_MODE,secretKey);
byte[] output = cipher.doFinal(input);
```

自己实践下。

### TLS协议分析

https://datatracker.ietf.org/doc/rfc8446/

[1] RFC6176 - Prohibiting Secure Sockets Layer (SSL) Version 2.0
https://tools.ietf.org/html/rfc6176
[2] RFC7568 - Deprecating Secure Sockets Layer Version 3.0
https://tools.ietf.org/html/rfc7568
[3] RFC2246 - The TLS Protocol Version 1.0
https://tools.ietf.org/html/rfc2246
[4] RFC4346 - The Transport Layer Security (TLS) Protocol Version 1.1
https://tools.ietf.org/html/rfc4346
[5] RFC5246 - The Transport Layer Security (TLS) Protocol Version 1.2
https://tools.ietf.org/html/rfc5246
[6] RFC2246 - The TLS Protocol Version 1.0
https://tools.ietf.org/html/rfc2246
[7] RFC4346 - The Transport Layer Security (TLS) Protocol Version 1.1
https://tools.ietf.org/html/rfc4346
[8] RFC5246 - The Transport Layer Security (TLS) Protocol Version 1.2
https://tools.ietf.org/html/rfc5246
[9] The Transport Layer Security (TLS) Protocol Version 1.3
https://tools.ietf.org/html/draft-ietf-tls-tls13-13
[10] SSL and TLS Protocols
https://wiki.openssl.org/index.php/SSL_and_TLS_Protocols

关于ASN.1的学习：自行搜索下

https://wenku.baidu.com/view/c179bc4ab14e852459fb574c.html?fr=search-1_income1

![image-20200925164959323](https://tva1.sinaimg.cn/large/007S8ZIlly1gj2zu56r92j30sc0hagmc.jpg)

![image-20200925161759374](https://tva1.sinaimg.cn/large/007S8ZIlly1gj2ywuicj2j30xs0tmwil.jpg)

具体协议分析如下：

![image-20200925162715443](https://tva1.sinaimg.cn/large/007S8ZIlly1gj2z6i2l64j31j60u0kav.jpg)

ClientHello请求：（信息摘要VS加密算法）

~~~c
此时握手协议(handshake protocol)的消息类型为:client hello
支持的TLS协议版本，比如TLS 1.0版。握手协议的版本为TLS 1.2
一个客户端生成的随机数，稍后用于生成"对话密钥"。
支持的加密套件，如Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)
支持的压缩方法。
扩展属性如：服务器名称（www.baidu.com)，支持的签名算法等
2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。
~~~

服务器响应（SeverHello）:

~~~c
确认使用的加密通信协议版本，这里确认使用tls1.2，而不是client hello中的tls1.1。响应握手协议消息 server hello。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
一个服务器生成的随机数，稍后用于生成"对话密钥"。
确认使用的加密套件,这里为rsa+aes128+sha256
压缩方法为空。
一些列扩展信息
~~~

![image-20200925163200734](https://tva1.sinaimg.cn/large/007S8ZIlly1gj2zbg3u0lj31hh0u0nfu.jpg)

从封装内容看，包含两层ssl协议体信息，头一个为服务端证书，后面跟着公共密钥交换和hello done消息体，具体如下：

   (1)详细的电子证书信息和CA认证机构信息.
（2）密钥交换信息，包括DH算法计算出的pubkey公钥，电子签名的hash算法值.
（3）server hello done消息体.

这里需要注意：如何保证公钥不被篡改。

将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。所以上面报文中就将服务端CA证书和公共密钥交换消息放在同一个tcp连接进行传输。

**客户端发送密钥交换信息（client key exchange）、编码改变协议消息(change cipher spec)**：

![image-20200925163912881](https://tva1.sinaimg.cn/large/007S8ZIlly1gj2zixnd9nj326i0u07fe.jpg)(1)发送DH算法计算的pubkey，用于服务端计算生成解密私钥
(2) 送编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
(3) 发送加密后的握手消息，一个随机数。该随机数用服务器公钥加密，防止被窃听
(4) 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。（可能在加密消息中，未确认）

客户端收到服务器所有响应消息后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 
如果证书没有问题，客户端就会从证书中取出服务器的公钥，即server key exchange消息中携带的pubkey值。然后，根据根据已经收到的三个随机数计算书加密密钥，对握手信息进行加密通信，然后向服务器发送上面抓包中三项信息内容。

该步骤中的随机数，是整个握手阶段出现的第三个随机数，又称”pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。

注意：SSL 握手的流程并不是一成不变的，根据实际的应用场景来区分；

SSL 握手的流程并不是一成不变的，根据实际的应用场景来。

![image-20201009215039092](https://tva1.sinaimg.cn/large/007S8ZIlly1gjjf7cslikj30wp0u0gta.jpg)

**经典面试问题：**

- HTTPS在传输的过程中会涉及到几个密钥？

服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密。

- 一个HTTPS请求实际上包含了几次HTTP传输？

~~~c
1、客户端向服务器发起HTTPS请求，连接到服务器的443端口。
2、服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3、服务器将自己的公钥发送给客户端。
4、客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5、客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6、服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7、然后服务器将加密后的密文发送给客户端。
8、客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。
~~~

- 数字证书是什么？Https是否一定需要数字证书的存在？

当服务器接收到客户端发来的请求时，会向客户端发送服务器自己的公钥，但是黑客有可能中途篡改公钥，将其改成黑客自己的。所以数字证书的作用就是担保服务器的公钥。

### Android操作Https的经典范例

~~~java
public final static String SSL_KEY = "-----BEGIN CERTIFICATE-----\n" +
            "Fw0xODAxMTYwMDAwMDBaFw0yMDAyMTUxMjAwMDBaMIGdMQswCQYDVQQGEwJDTjEQ\n" +
            "MA4GA1UEBxMHQ2hlbmdkdTE4MDYGA1UEChMvQ2hpbmEgTW9iaWxlIElPVCBDb21w\n" +
            "YW55IExpbWl0ZWQgQ2hlbmdkdSBicmFuY2gxJjAkBgNVBAsTHUluZm9ybWF0aW9u\n" +
            "IFRlY2hub2xvZ3kgQ2VudGVyMRowGAYDVQQDExF3d3cudGF4aWFpZGVzLmNvbTCC\n" +
            "ASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOryUl/OGkrUkqSzoimarOPv\n" +
            "V0qQ7EsyS1ny0UZ7jcxnFS7ztOLh/0XIaPvX4e2KWgdcgxL8LbQ/gFKeRr5s6Uub\n" +
            "QUeczE9+CO4ic5opzS76QVJVH0kTSBoB1HBJ0TAV3XhSt+SOF7T5bpJrcCdijw7X\n" +
            "-----END CERTIFICATE-----";

InputStream[] key = new InputStream[]{new Buffer().writeUtf8(SSL_KEY_TEST).inputStream()};

public static SSLParams setCertificates(InputStream... certificates)
    {
        SSLParams sslParams = new SSLParams();
        try
        {
            CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
            KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
            keyStore.load(null);
            int index = 0;
            for (InputStream certificate : certificates)
            {
                String certificateAlias = Integer.toString(index++);
                keyStore.setCertificateEntry(certificateAlias, certificateFactory.generateCertificate(certificate));

                try
                {
                    if (certificate != null){
                        certificate.close();
                    }
                } catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
            SSLContext sslContext = SSLContext.getInstance("TLS");

            TrustManagerFactory trustManagerFactory =
                    TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());

            trustManagerFactory.init(keyStore);
            sslContext.init
                    (
                            null,
                            trustManagerFactory.getTrustManagers(),
                            new SecureRandom()
                    );

            sslParams.trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
            sslParams.sSLSocketFactory = sslContext.getSocketFactory();
            return sslParams;
        } catch (Exception e)
        {
            e.printStackTrace();
        }
        return sslParams;
    }
~~~

#### 中间人篡改整个证书

Charles怎么操作的？？思考一下？Https是否能真正的防止中间人攻击？

- 客户端跟Charles通信，Charles再跟服务器去通信，两个过程都是完整的HTTPS通信。
- 抓包软件可解析HTTPS报文的原因是，用户主动给该抓包软件安装了证书，并手动选择信任该证书，而且要设置代理为这个软件。

记住结论：不能防止用户主动做中间人攻击的破解 HTTPS。

https://docs.mitmproxy.org/stable/

https://github.com/mitmproxy/mitmproxy

**透明HTTPS代理**：

https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/

http://wiki.cacert.org/FAQ/ImportRootCert#Android_Phones_.26_Tablets

### 关于Android抓包的问题总结

https://developer.android.com/training/articles/security-config.html

方法1:操作系统层面

~~~xml
添加如下文件 res/xml/network_security_config.xml 到你的代码里面，然后就能实现debug模式下，信任用户自己安装的根证书，比如Charles的证书:

<network-security-config> 
  <!-- Trust user added CAs while debuggable only -->
  <debug-overrides> 
    <trust-anchors> 
      <!--信任用户安装的证书-->
      <certificates src="user" /> 
    </trust-anchors> 
  </debug-overrides> 
</network-security-config>

然后在你 app的 manifest 文件中引入上面的文件, 如下所示:

<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:networkSecurityConfig="@xml/network_security_config" ... >
        ...
    </application>
</manifest>
~~~

方法2:targetSdkVersion<24

~~~c
defaultConfig {
        applicationId "me.febsky.okhttp.test"
        minSdkVersion 19
        targetSdkVersion 22
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
~~~

在逆向别人的app的时候，我们可以打包。

方法3:框架层面，不验证证书 （需要验证）

**如何在Android 7.X 以上系统中抓第三方app的https包**

核心：xposed JustTrustMe

**自签名证书的应用和双向验证的应用抓包**。

### Android网络优化

**重点指标：**

- 业务成功率：网络信号差和拥塞网络2种环境下会有问题。
- 业务网络延时：需要做全链路的监测，掌握数据包的发送历程。比如DNS的解析、TCP建立链接的过程、接受窗口等问题。
- 业务宽带成本：压缩问题（音视频、Gzip、protobuf）、RecyclerVIew的增量问题、
- 业务安全性：TLS核心理解

**DNS优化**

**复用连接池**

**弱网优化**