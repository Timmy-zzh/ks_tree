https://blog.csdn.net/zhangjg_blog/article/details/22976929

##### 前言

- JVM在运行时，加载并执行class文件，这个class文件是由编写好的java源文件经过javac编译而得到。
- 有时候会遇到一种情况，前期编写程序时不知道要写什么类，只有到运行时，才能根据当时的程序执行状态知道要使用什么类。
  - 常见的处理方式可以使用JDK中的动态代理
  - 还有一个叫做ASM的库，能够直接生成class文件，它的api对于动态代理来说更加原生，每个api都和class文件格式中的特定部分吻合。

动态生成如下class文件：

~~~java
public class AsmDemo11 {

    public static void main(String[] var0) {
        System.out.println("Hello ASM 123");
    }
}

~~~

##### 使用ASM框架实现：

添加依赖：

~~~java
    //ASM依赖
    implementation 'org.ow2.asm:asm:7.2'
    implementation 'org.ow2.asm:asm-commons:7.2'
~~~

代码实现：

~~~java
public class MyClass extends ClassLoader implements Opcodes {

    public static void main(String[] args) throws Exception {
        System.out.println("-----MyClass----");
        //定义一个类模版
        ClassWriter cw = new ClassWriter(0);
        cw.visit(V1_7, ACC_PUBLIC, "AsmDemo11", null, "java/lang/Object", null);

        //TODO 1构造默认构造函数
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
                "<init>",
                "()V",
                null, null);
        //生成构造函数字节码指令 -- 加载操作
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL,
                "java/lang/Object",
                "<init>",
                "()V",
                false);
        mv.visitInsn(RETURN);
        mv.visitMaxs(1, 1);
        mv.visitEnd();

        //TODO 2.构造main函数
        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,
                "main",
                "([Ljava/lang/String;)V",
                null,
                null);

        //TODO 3.main方法中生成 System.out.println("Hello ASM");
        //获取System类中的属性  System.out --    public static final PrintStream out;
        mv.visitFieldInsn(GETSTATIC,
                "java/lang/System",
                "out",
                "Ljava/io/PrintStream;");

        //栈帧中 属性入栈
        mv.visitLdcInsn("Hello ASM 123");
        //加载 println 方法
        mv.visitMethodInsn(INVOKEVIRTUAL,
                "java/io/PrintStream",
                "println",
                "(Ljava/lang/String;)V",
                false);
        mv.visitInsn(RETURN);
        mv.visitMaxs(2, 2);

        //TODO 4.字节码生成完毕
        mv.visitEnd();

        //获取生成的class 文件对应的二进制流
        byte[] codes = cw.toByteArray();

        //将二进制流写入到本地磁盘上
        FileOutputStream fos = new FileOutputStream("AsmDemo11.class");
        fos.write(codes);
        fos.close();

        //反射调用
        MyClass loader = new MyClass();
        Class<?> defineClass = loader.defineClass("AsmDemo11", codes, 0, codes.length);
        defineClass.getMethods()[0].invoke(null, new Object[]{null});
    }
}

日志打印结果：
-----MyClass----
Hello ASM 123
~~~

#### 代码解析

##### 1.使用ClassWriter定义一个类

~~~java
        //定义一个类模版
        ClassWriter cw = new ClassWriter(0);
        cw.visit(V1_7, ACC_PUBLIC, "AsmDemo11", null, "java/lang/Object", null);
~~~

  - ClassWriter的visit方法定义一个类
    		- 参数1：V1_7 - 是生成class的版本号，对应class文件中的主版本号和次版本号，
    		- 参数2：ACC_PUBLIC - 表示该类的访问标识。这是一个public类，对应class文件的access_flags
    		- 参数3：生成类的类名，需要传入全类名。对应class文件中的this_class
    		- 参数4：表示泛型，传入null表示这不是一个泛型类。对那个class文件中的Signature属性（attribute）
    		- 参数5：当前类的父类的全限类名。该类直接继承自Object。对应class文件中的super_class
    		- 参数6：表示当前生成类的直接实现接口，为string[]类型，可以实现多个接口。这个类没有实现任何接口，所以传入null。敌营class文件中的interfaces

##### 2.定义默认构造函数

~~~java
        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC,
                "<init>",
                "()V",
                null, null);
        //生成构造函数字节码指令 -- 加载操作
        mv.visitVarInsn(ALOAD, 0);
        mv.visitMethodInsn(INVOKESPECIAL,
                "java/lang/Object",
                "<init>",
                "()V",
                false);
        mv.visitInsn(RETURN);
        mv.visitMaxs(1, 1);
        mv.visitEnd();
~~~

- 调用ClassWriter的visitMethod方法返回一个MethodVisitor对象，该对象定义了一个方法，对应class文件中的一个method_info
  - 参数1：ACC_PUBLIC - 指定生成方法的访问标志，对应method_info中的access_flags
  - 参数2：方法的方法名。构造方法名为< init >，对应method_info中的name_index，引用常量池中的方法名字符串
  - 参数3：方法描述符，因为生成的构造方法无入参和无返回值，所以方法描述符为()V.对应method_info中的descriptor_index
  - 参数4：泛型相关，传入nulli表示该方法不是泛型方法。对应method_info中的Signature属性
  - 参数5：指定方法声明可能抛出的异常。传入null表示无异常声明抛出。对应method_info中的Exceptions属性
- 接着调用MethodVisitor中的方法，生成当前构造方法的字节码，对应method_info中的Code属性
  - 调用visitVarInsn方法，生成aload指令，将第0个本地变量（也就是this）压入操作数栈
  - 调用visitMethodInsn方法，生成invokespecial指令，调用父类（也就是Object）的构造方法
  - 调用visitInsn 方法，生成return指令，方法返回
  - 调用visitMaxs 方法，指令当前要生成方法的最大局部变量和最大操作数栈。对应Code属性中的max_stack和 max_locals
  - 最后调用visitEnd 方法，表示当前要生成的构造方法已经创建完成































