Java内存模型：Java Memory Model，简称JMM，描述了多线程并发，CPU缓存等内容

#### 1.为什么设计Java内存模型

##### 1.1.工作内存与主内存

<img src=".\res1\1.工作内存与主内存.png" alt="1.工作内存与主内存" style="zoom:50%;" />

- 在每一个线程中，都会有一块内部的工作内存。这块内存保存了主内存共享数据的拷贝副本。
  - 在程序运行时内存分配中，线程私有的内存空间包括：虚拟机栈，程序计数器，本地方法栈
  - 虚拟机栈与线程的工作内存不是一个概念，在java线程中并不存在所谓的工作内存，它只是对CPU寄存器和高速缓存的抽象描述。

##### 1.2.CPU

- 线程是CPU调度的最小单位，线程中的字节码指令最终都是在CPU中执行的。
- CPU在执行的时候，免不了要和各种数据打交道，而Java中所有数据都是存放在主内存(RAM)当中的。

CPU指令执行与数据调度流程图：

<img src=".\res1\2.CPU指令执行与数据调度流程图.png" alt="2.CPU指令执行与数据调度流程图" style="zoom:50%;" />

- 随着CPU技术的发展，CPU的执行速度越来越快，但内存的技术并没有太大的变化
  - 所以在内存中读取和写入数据的过程和CPU的执行速度比起来差距会越来越大。
  - CPU对主内存的访问需要等待较长的时间，这样体现不出CPU超强运算能力的优势
- 因此: 为了“压榨”处理性能，达到“高并发”的效果，在CPU中添加了高速缓存（Cache）来作为缓冲

<img src=".\res1\3.CPU高速缓冲.png" alt="3.CPU高速缓冲" style="zoom:50%;" />

- 执行任务时，CPU会先将运算所需要使用到的数据复制到高速缓存中，让运算能够快速进行，当运算完成之后，再将缓存中的结果刷回（flush back）主内存，这样CPU就不用等待主内存的读写操作了
  - 问题：每个处理器都有自己的高速缓存，同时又共同操作同一块主内存，当多个处理器同时操作主内存时，可能导致数据不一致，这就是缓存一致性问题

##### 1.3.缓存一致性问题

- 现在市面上的手机都有两个或多个CPU，其中一些CPU还有多核。每个CPU在某一时刻都能运行一个线程。如果程序时多线程的，就有可能存在多个线程在同一时刻被不同的CPU执行的情况

如下多线程代码：

~~~java
    public int x = 0;
    public int y = 0;

    private void test() {
        Thread thread1 = new Thread() {
            @Override
            public void run() {
                int a = x;
                y = 1;
                System.out.println("thread1--  x:" + x + " ,y:" + y + " ,a:" + a);
            }
        };

        Thread thread2 = new Thread() {
            @Override
            public void run() {
                int b = y;
                x = 2;
                System.out.println("thread2===x:" + x + " ,y:" + y + " ,b:" + b);
            }
        };
        thread1.start();
        thread2.start();
    }
~~~

- 假设上诉代码运行在一台有2个CPU的设备上，代码执行的结果有如下几种结构：

1. 情况一：a=0，b=1;
   - thread1先在CPU1中执行完毕，并成功刷新回主内存中，此时：a=0，x=0，y=1
   - thread2接着在CPU2中执行，从主内存中加载y=1复制给b，此时：b=1，x=2，y=1
2. 情况二：a=2，b=0
   - thread2先在CPU1中执行完毕，并成功刷新回主内存中，此时：b=0，x=2，y=0
   - thread1接着在CPU2中执行，从主内存中加载x=2复制给b，此时：a=2，x=2，y=1
3. 情况三：x和y的值分别缓存在CPU1和CPU2的高速缓存中
   - thread1先在CPU1中执行完毕，但是并未将结果刷新回主内存中，此时主内存中的：x=0，y=0
   - thread2接着在CPU2中执行，从主内存中加载y=0复制给b，此时缓存中：b=0，x=2，y=0；而主内存中的：x=0，y=0

**可以发现，虽然在CPU1和CPU2的缓存中，分别修改了x和y的值，但是并未将他们刷新回主内存中，这就是缓存一致性的问题**

##### 2.4.指令重排



























