#### 1.Synchronized

##### synchronized可以用来修饰以下3个层面

- 修饰实例方法
- 修饰静态类方法
- 修饰代码块

##### 1.1.Synchronized修饰实例方法 -- 对象锁

~~~java
public class _02SynchronizedMethod {

    public static void main(String[] args) {
        _02SynchronizedMethod demo1 = new _02SynchronizedMethod();
        _02SynchronizedMethod demo2 = new _02SynchronizedMethod();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo2.printLog();
            }
        });

        thread1.start();
        thread2.start();
    }

    private synchronized void printLog() {
        try {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread Name:" + Thread.currentThread().getName() + " --- i:" + i);
                Thread.sleep(300);
            }
        } catch (Exception e) {
        }
    }
}

日志输出：
> Task :testlib:_02SynchronizedMethod.main()
Thread Name:Thread-1 --- i:0
Thread Name:Thread-0 --- i:0
Thread Name:Thread-1 --- i:1
Thread Name:Thread-0 --- i:1
Thread Name:Thread-1 --- i:2
Thread Name:Thread-0 --- i:2
Thread Name:Thread-1 --- i:3
Thread Name:Thread-0 --- i:3
Thread Name:Thread-1 --- i:4
Thread Name:Thread-0 --- i:4
~~~

- 可以看出，两个线程是交互执行的，上诉情况下的锁对象是当前实例对象，不同对象实例之间方法调用不会有互斥效果。

**代码修改为不同线程调用同一个对象实例的方法**

~~~java
public class _02SynchronizedMethod {

    public static void main(String[] args) {
        _02SynchronizedMethod demo1 = new _02SynchronizedMethod();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });

        thread1.start();
        thread2.start();
    }

    private synchronized void printLog() {
        try {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread Name:" + Thread.currentThread().getName() + " --- i:" + i);
                Thread.sleep(300);
            }
        } catch (Exception e) {
        }
    }
}

日志输出：
> Task :testlib:_02SynchronizedMethod.main()
Thread Name:Thread-0 --- i:0
Thread Name:Thread-0 --- i:1
Thread Name:Thread-0 --- i:2
Thread Name:Thread-0 --- i:3
Thread Name:Thread-0 --- i:4
Thread Name:Thread-1 --- i:0
Thread Name:Thread-1 --- i:1
Thread Name:Thread-1 --- i:2
Thread Name:Thread-1 --- i:3
Thread Name:Thread-1 --- i:4
~~~

- 可以看出：只有某一个线程中的代码执行完之后，才会调用另一个线程中的代码。说明两个线程是互斥的。

##### 1.2.修饰静态类方法

使用synchronized修饰的静态方法，锁对象使用的是当前类的Class对象。因此即使在不同线程中调用不同实例对象，也会有互斥效果。

~~~java
package com.timmy.testlib;

public class _03SynchronizedStaticMethod {

    public static void main(String[] args) {
        _03SynchronizedStaticMethod demo1 = new _03SynchronizedStaticMethod();
        _03SynchronizedStaticMethod demo2 = new _03SynchronizedStaticMethod();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo2.printLog();
            }
        });

        thread1.start();
        thread2.start();
    }

    private static synchronized void printLog() {
        try {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread Name:" + Thread.currentThread().getName() + " --- i:" + i);
                Thread.sleep(300);
            }
        } catch (Exception e) {
        }
    }
}

日志输出：
> Task :testlib:_03SynchronizedStaticMethod.main()
Thread Name:Thread-0 --- i:0
Thread Name:Thread-0 --- i:1
Thread Name:Thread-0 --- i:2
Thread Name:Thread-0 --- i:3
Thread Name:Thread-0 --- i:4
Thread Name:Thread-1 --- i:0
Thread Name:Thread-1 --- i:1
Thread Name:Thread-1 --- i:2
Thread Name:Thread-1 --- i:3
Thread Name:Thread-1 --- i:4
~~~

- 两个线程是依次执行的

##### 1.3.synchronized修饰代码块

~~~java
package com.timmy.testlib;

public class _02_3Synchronized {

    private Object lock = new Object();

    public static void main(String[] args) {
        _02_3Synchronized demo1 = new _02_3Synchronized();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });

        thread1.start();
        thread2.start();
    }

    private void printLog() {
        synchronized (lock) {
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread Name:" + Thread.currentThread().getName() + " --- i:" + i);
            }
        }
    }
}

日志输出：
> Task :testlib:_02_3Synchronized.main()
Thread Name:Thread-0 --- i:0
Thread Name:Thread-0 --- i:1
Thread Name:Thread-0 --- i:2
Thread Name:Thread-0 --- i:3
Thread Name:Thread-0 --- i:4
Thread Name:Thread-1 --- i:0
Thread Name:Thread-1 --- i:1
Thread Name:Thread-1 --- i:2
Thread Name:Thread-1 --- i:3
Thread Name:Thread-1 --- i:4
~~~

- synchronized作用域代码块时，锁对象就是后面括号中的对象，Object对象都可以当作锁对象

##### 1.4.synchronized实现原理：monitorenter 与 monitorexit 字节码指令

##### 如下代码synchronized修饰代码块：

~~~java
    public int add(int i) {
        synchronized (this) {
            int j = 10;
            num = num + i;
            return num;
        }
    }

javap 查看对应字节码：
  public int add(int);
    descriptor: (I)I
    flags: ACC_PUBLIC
    Code:
      stack=3, locals=5, args_size=2
         0: aload_0
         1: dup
         2: astore_2
         3: monitorenter
         4: bipush        10
         6: istore_3
         7: aload_0
         8: aload_0
         9: getfield      #2                  // Field num:I
        12: iload_1
        13: iadd
        14: putfield      #2                  // Field num:I
        17: aload_0
        18: getfield      #2                  // Field num:I
        21: aload_2
        22: monitorexit
        23: ireturn
        24: astore        4
        26: aload_2
        27: monitorexit
        28: aload         4
        30: athrow
~~~

- 如上add方法字节码中有1个monitorenter和2个monitorexit指令。这是因为虚拟机需要保证当异常发生时也能释放锁。
  - 因此2个monitorexit一个是代码正常执行结束后释放锁，一个是在代码执行异常时释放锁。

##### synchronized关键字修饰方法字节码实现：

~~~java
    public synchronized int add(int i) {
        num = num + i;
        return num;
    }
对应字节码：
  public synchronized int add(int);
    descriptor: (I)I
    flags: ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=3, locals=2, args_size=2
         0: aload_0
         1: aload_0
         2: getfield      #2                  // Field num:I
         5: iload_1
         6: iadd
         7: putfield      #2                  // Field num:I
        10: aload_0
        11: getfield      #2                  // Field num:I
        14: ireturn
~~~

- 上述代码可以看出，被synchronized修饰的方法在被编译为字节码后，在方法的flags属性中会被标记为ACC_SYNCHRONIZED标志。
  - 当虚拟机访问一个被标记为ACC_SYNCHRONIZED的方法时，会自动在方法的开始和结束（异常）位置添加monitorenter和monitorexit指令

##### 关于monitorenter和monitorexit，可以理解为一把具体的锁。

- 在这个锁中保存着两个比较重要的属性：计数器和指针
  - 计数器代表当前线程一共访问了几次这把锁
  - 指针指向持有这把锁的线程

如图：

<img src=".\res2\1.monitorenter和monitorexit指令原理图png.png" alt="1.monitorenter和monitorexit指令原理图png" style="zoom:80%;" />

- 锁计数器默认为0
  - 当执行monitorenter指令时，如锁计数器值为0说明这把锁并没有被其他线程持有，那么这个线程会将计数器加1，并将锁中的指针指向自己。
  - 当执行monitorexit指令时，会将计数器减1.

#### 2.ReentrantLock

##### 2.1.ReentrantLock基本使用

- ReentrantLock的使用与synchronized不同，它的加锁和解锁都需要手动完成，如下：

~~~java
public class _03ReentrantLockDemo {
    ReentrantLock reentrantLock = new ReentrantLock();

    public static void main(String[] args) {
        _03ReentrantLockDemo demo1 = new _03ReentrantLockDemo();

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });
        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                demo1.printLog();
            }
        });

        thread1.start();
        thread2.start();
    }

    private void printLog() {
        try {
            reentrantLock.lock();
            for (int i = 0; i < 5; i++) {
                System.out.println("Thread Name:" + Thread.currentThread().getName() + " --- i:" + i);
                Thread.sleep(300);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            reentrantLock.unlock();
        }
    }
}

日志打印：
> Task :testlib:_03ReentrantLockDemo.main()
Thread Name:Thread-0 --- i:0
Thread Name:Thread-0 --- i:1
Thread Name:Thread-0 --- i:2
Thread Name:Thread-0 --- i:3
Thread Name:Thread-0 --- i:4
Thread Name:Thread-1 --- i:0
Thread Name:Thread-1 --- i:1
Thread Name:Thread-1 --- i:2
Thread Name:Thread-1 --- i:3
Thread Name:Thread-1 --- i:4
~~~

- 解析
  - 使用ReentrantLock也能实现同synchronized相同的效果
- ReentrantLock与synchronized不同
  - synchronized当异常发生时，synchronized会自动释放锁，但是ReentrantLock并不会自动释放锁，因此好的方式是将ReentrantLock的unlock操作放在finally代码块中，保证在任何时候锁都能够被正常释放掉

##### 2.2.公平锁实现



##### 2.3.读写锁































