##### Java线程切换的实质

- Java的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙。
  - 这就要从用户态转换到和心态，且状态转换需要花费很多处理器时间

如下代码：

~~~java
    private Object lock = new Object();
    private int value = 0;

    public void setValue() {
        synchronized (lock) {
            value++;
        }
    }
~~~

- 上诉代码中value++ 因为被关键字synchronized修饰，所以会在各个线程间同步执行。
  - 但是value++消耗的时间很有可能比线程状态转换消耗的时间还短。**所以说synchronized是java语言中一个重量级的操作**

#### 1.synchronized实现原理

##### 对象头和Monitor

#### 对象头

- Java对象在内存中的布局分为3部分：对象头，实例数据，对齐填充。
- java代码中，使用new关键字创建一个对象时，jvm会在堆中创建一个instanceOopDesc对象，这个对象中包含了对象头以及实例数据

instanceOopDesc的基类为oopDesc类，结构如下：

~~~c++
class oopDesc {
  	friend class VMStructs;
 	private:
  		volatile markOop  _mark;
  		union _metadata {
    		wideKlassOop  _klass;
    		narrowOop     _compressed_klass;
  	} _metadata;
~~~

- 其中 __mark 和 _metadata 一起组成对象头。_
  - _metadata主要保存了类元数据。
  -  _mark 时 markOop类型数据，一般称为标记字段（Mark Word），其中主要存储了对象的hashCode，分代年龄，锁标志位，是否偏向锁等

32位Java虚拟机的Mark Word的默认存储结构如下：

<img src=".\res3\1.32位jvm的Mark Word默认存储结构.png" alt="1.32位jvm的Mark Word默认存储结构" style="zoom:42%;" />

- 默认情况下，没有线程进行加锁操作，所以对象中的Mark Word处于无锁状态。
  - 考虑到jvm的空间效率，Mark Word被设计成一个非固定的数据结构，以便存储更多的有效数据。
  - 他会根据对象本身的状态复用自己的存储空间，如32位jvm下，除了Mark Word的默认存储结构外，还有如下可能存在的结构：

<img src=".\res3\2.Mark Word其他可能结构.png" alt="2.Mark Word其他可能结构" style="zoom:48%;" />

- 从图中可以看出，根据“锁标志位”以及“是否为偏向锁”，Java中的锁可以分为以下几种状态：

| 是否偏向锁 | 锁标志位 |  锁状态  |
| :--------: | :------: | :------: |
|     0      |    01    |   无锁   |
|     1      |    01    |  偏向锁  |
|     0      |    00    | 轻量级锁 |
|     0      |    10    | 重量级锁 |
|     0      |    11    |  GC标记  |

- 在Java6之前，并没有轻量级锁和偏向锁，只有重量级锁，也就是说synchronized的对象锁，锁标志位为10。
  - 当锁是重量级锁时，对象头中Mark Word会用30bit来指向一个“互斥量”，这个互斥量就是Monitor

#### Monitor





























