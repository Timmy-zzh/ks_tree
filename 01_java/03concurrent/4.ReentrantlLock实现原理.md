##### AQS

- AQS全称是Abstract Queued Synchronizer,翻译为同步器，它是一套实现多线程同步功能的框架。AQS在源码中被广泛使用，特别是在java高并发编程中，比如ReentrantLock，Semaphore，CountDownLatch和ThreadPoolExecutor，在实际开发中也可以通过自定义AQS来实现各种需求场景。

#### ReentrantLock的同步功能的原理就是通过AQS来实现的

- ReentrantLock的加锁方法lock()

~~~java
public class ReentrantLock implements Lock, Serializable {
    
    private final ReentrantLock.Sync sync;

    public ReentrantLock() {
        this.sync = new ReentrantLock.NonfairSync();
    }

    public ReentrantLock(boolean fair) {
        this.sync = (ReentrantLock.Sync)(fair ? new ReentrantLock.FairSync() : new ReentrantLock.NonfairSync());
    }

    public void lock() {
        this.sync.lock();
    }

    abstract static class Sync extends AbstractQueuedSynchronizer {

        abstract void lock();

        final boolean nonfairTryAcquire(int acquire) {}

        protected final boolean tryRelease(int release) {}

        protected final boolean isHeldExclusively() {}

        final ConditionObject newCondition() {}

        final Thread getOwner() {}

        final int getHoldCount() {}

        final boolean isLocked() {}

        private void readObject(ObjectInputStream var1) {}
    }
}
~~~

- 解析
  - ReentrantLock的lock方法调用的是sync的lock方法，sync是ReentrantLock的变量Sync的对象实例
  - Sync是ReentrantLock的静态内部类，该类继承自AbstractQueuedSynchronizer
  - Sync类有有两个实现类-NonfairSync 和 FairSync，这两个类也是ReentrantLock的静态内部类，分别对应非公平锁和公平锁。
    - 这两个类通过ReentrantLock的带参构造函数确定实现，默认sync为非公平锁NonfairSync实现

##### NonfairSync实现源码如下：

~~~java
    static final class NonfairSync extends ReentrantLock.Sync {
        private static final long serialVersionUID = 7316153563782823691L;

        NonfairSync() {
        }

        final void lock() {
            //1.通过cas操作来修改state状态，表示争抢锁的操作
            if (this.compareAndSetState(0, 1)) {
                //2.修改状态成功，则设置当前获得锁状态的线程为当前执行线程
                this.setExclusiveOwnerThread(Thread.currentThread());
            } else {
                //3.修改状态失败，调用AQS的acquire方法进行后续处理
                this.acquire(1);
            }
        }

        protected final boolean tryAcquire(int var1) {
            return this.nonfairTryAcquire(var1);
        }
    }
~~~

- 解析：在非公平锁NonfairSync的lock方法中，主要操作如下
  - 调用compareAndSetState方法，通过cas设置变量state（同步状态）成功，表示当前线程获取锁成功，则将当前线程设置为独占线程。
  - 如果通过cas设置变量state成功，表示当前锁正在被其他线程持有，则调用AQS的acquire方法进行后续操作

##### AbstractQueuedSynchronizer的acquire方法

~~~java
public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer {
    
    private transient volatile AbstractQueuedSynchronizer.Node head;
    private transient volatile AbstractQueuedSynchronizer.Node tail;
    private volatile int state;
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    
    protected AbstractQueuedSynchronizer() {
    }

    protected final int getState() {
        return this.state;
    }

    protected final void setState(int var1) {
        this.state = var1;
    }

    protected final boolean compareAndSetState(int var1, int var2) {
        return unsafe.compareAndSwapInt(this, stateOffset, var1, var2);
    }
    
    public final void acquire(int var1) {
        if (!this.tryAcquire(var1) && this.acquireQueued(this.addWaiter(AbstractQueuedSynchronizer.Node.EXCLUSIVE), var1)) {
            selfInterrupt();
        }
    }
    
    protected boolean tryAcquire(int var1) {
        throw new UnsupportedOperationException();
    }
}
~~~

- 解析：AQS的acquire方法比较重要，该方法中主要有3个重要步骤
  - tryAcquire 方法主要目的是尝试获取锁
    - AQS中的tryAcquire 比较特殊，默认情况下会直接抛异常，因此需要在子类复写，所以重点看非公平锁NonfairSync的tryAcquire 的代码实现
  - 如果当前线程调用tryAcquire 获取锁失败，则会调用addWaiter()方法，该方法的作用是将当前线程添加到一个等待队列中，并返回新添加队列的节点Node
  - 接着会调用acquireQueued 方法，将加入到队列中的节点，通过自旋去尝试获取锁，根据情况将线程挂起或者取消。

##### NonfairSync的tryAcquire方法

- NonfairSync的tryAcquire会调用Sync的nonfairTryAcquire方法

~~~java
    static final class NonfairSync extends ReentrantLock.Sync {
        
        protected final boolean tryAcquire(int acquires) {
            return this.nonfairTryAcquire(acquires);
        }
    }

    abstract static class Sync extends AbstractQueuedSynchronizer {

        abstract void lock();

        final boolean nonfairTryAcquire(int acquires) {
            //获取当前执行的线程
            Thread current = Thread.currentThread();
            //获得state的值
            int state = this.getState();
            // state为0，表示当前无锁状态
            if (state == 0) {
                //无锁状态下，通过cas操作将state的值设置为1，设置当前线程持有锁
                if (this.compareAndSetState(0, acquires)) {
                    this.setExclusiveOwnerThread(current);
                    return true;
                }
            } 
            // 如果state不为0，说明当前已有线程持有锁，如果当前持有锁的线程就是当前线程
            // 则增加锁的重入次数，将state加1并重新设置
            else if (current == this.getExclusiveOwnerThread()) {
                int newState = state + acquires;
                if (newState < 0) {
                    throw new Error("Maximum lock count exceeded");
                }
                this.setState(newState);
                return true;
            }
            return false;
        }
    }
~~~

- 解析：tryAcquire方法的作用是尝试获取锁，并返回获取锁的结果是否成功
  - AQS中有一个变量state，表示当前锁的状态
  - 如果state为0表示当前是无锁状态，通过cas更新state状态的值为1，并设置当前线程持有锁，并返回true，表示获取锁成功
  - 如果当前线程属于重入，则增加重入次数，返回true
  - 如果上诉情况都不满足，则获取锁失败，返回false

ReentrantLock的lock方法调用流程图：

<img src=".\res4\1.ReentrantLock的lock加锁流程图.png" alt="1.ReentrantLock的lock加锁流程图" style="zoom:70%;" />







































