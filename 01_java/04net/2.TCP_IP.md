#### 1.TCP概述

- TCP是面向连接的通信协议，通过三次握手建立连接，然后才能开始数据的读写，通讯完成时要断开连接，由于TCP是面向连接的所以只能用于端到端的通讯
- TCP提供的是一种可靠的数据流服务，数据有可能被拆分后发送，那么采用超时重传机制和应答确认机制是组成TCP可靠传输的关键涉及
  - 超时重传机制中最重要的就是重传超时的时间选择
    - RTT（round-trip-time往返时延）：根据网络情况动态调整
    - 需要采样统计一个数据包从发送端发送出去，到接收到这个包的回复这段时长来动态设置重传超时值。
- IP层进行数据传输时，时不能保证数据包按照发送顺序到达目的机器的。当接收端IP网络层将数据向上传送到TCP层后，TCP将包排序并进行错误检查。
  - TCP数据包中包括序号和确认，所以未按照顺寻收到的包可以被排序，而顺坏的包可以被重传
- TCP采用一种称为“滑动窗口”的方式进行流量控制，**所谓窗口实际表示接收能力，用以限制发送方的发送速度。**
- 同时TCP还允许在一个TCP连接上，通信的双方可以同时传输数据，也就是所谓的全双工。
- 面向连接的服务（Telnet，FTP，rlogin，SMTP等）需要高度的可靠性，所以使用了TCP。

#### 2.TCP三次握手

<img src=".\res2\1.TCP三次握手.png" alt="1.TCP三次握手" style="zoom:70%;" />

- TCP提供面向有连接的通信传输。面向有连接的是指在数据通信开始之前先做好两端之间的准备工作

**所谓三次握手：**是指建立一个TCP连接时需要客户端和服务端总共发送三个包以确认连接的建立，在socket编程中，这以过程由客户端执行connect来触发。

**第一次握手：**客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进行SYN_SENT状态，等待服务器端确认。

**第二次握手：**服务器端收到数据包后，由标志位SYN=1知道客户端请求连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态

**第三次握手：**客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

##### 2.2为什么需要三次握手

- TCP是可靠的传输控制协议，而三次握手是保证数据可靠传输又能提高传输效率的最小次数。
  - 为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，那些是已经被对方收到的。
  - 三次握手的过程是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。

##### 2.3 TCP三次握手的漏洞-SYN洪泛攻击

- 攻击者伪造IP，往服务器端狂发送第一次握手的内容。服务器忙于进行第二次握手但是第二次握手没有结果，所以导致服务器端被拖累，死机
- 解决方案
  - 无效连接建视释放
  - 延缓TCB分配方法
  - 使用防火墙

#### 3.TCP 四次挥手（分手）

**四次挥手即终止TCP连接，指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。这个过程由客户端或服务端任一方执行close来触发**

- 由于TCP连接时全双工模式的，因此，每个方向都必须要单独进行关闭
  - 当甲方完成数据发送任务后，发送一个FIN给乙方来终止这一方向的连接。
  - 乙方收到一个FIN只是意味着不会再收到甲方数据了，但是乙方依然可以给甲方发送数据，直到乙方也发送了FIN给甲方。
  - 首先进行关闭的乙方将执行主动关闭，而另一方则执行被动关闭。

<img src=".\res2\2.四次挥手.png" alt="2.四次挥手" style="zoom:65%;" />

TCP建立一个连接需3个分节，终止一个连接需4个分节

1. 某个应用进程首先调用close，我们称该端执行主动关闭（active close）。该端的TCP发送一个FIN分节，表示数据发送完毕，应用进程进入FIN-WAIT-1状态（终止等待1）
2. 接收到这个FIN的对端执行被动关闭（passive close），发出确认报文。这个FIN由TCP确认。因为FIN的接收意味着接收端应用进程再相应连接上再无额外数据可接收。
   - 接收端进入了CLOSE-WAIT（关闭等待）状态，这时候处于半关闭状态，即主动关闭端已经没有数据要发送了，但是被动关闭端若发送数据，主动关闭端依赖要接收。
   - 这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间
   - 主动关闭端收到确认报文后FIN-WAIT-2状态（终止等待2）
3. 一段时间后，被动关闭的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN
4. 接收到这个最终FIN的原先发送端TCP（主动关闭端）确认这个FIN发出一个确认ACK报文，并进入TIME-WAIT状态（时间等待）
   - 此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命/最长分节生命期）时间后，当主动关闭端撤销相应的TCB后，才进入CLOSE状态
5. 被动关闭端只要收到了客户端发出的确认，立即进入CLOSE状态。
   - 同样撤销TCB后，就结束了这次TCP的连接。可以看到，被动关闭端结束TCP连接的时间要比主动关闭端早一些

##### 3.2.为什么TCP挥手需要四次

- TCP是全双工模式

##### 3.3.为什么需要TIME-WAIT状态

- 可靠的终止TCP连接
- 保证让迟来的TCP报文由足够的时间被识别并丢弃



























