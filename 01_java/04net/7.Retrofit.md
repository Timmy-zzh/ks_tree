

https://blog.csdn.net/carson_ho/article/details/73732115

https://www.jianshu.com/p/768b2c2ab9e4



1. Retrofit

   - Retrofit是什么？
   - 为什么设计出来

2. Retrofit的基本使用

3. Retrofit 注解

   - 标示请求方法	

   - 参数类注解调用过程解析

4. 原理解析

5. 设计模式



#### 1.Retrofit

##### 1.1.Retrofit是什么？

- Retrofit是一个RESTful的HTTP网络请求框架的封装
- 网络请求的工作本质上是OkHttp框架完成的，而Retrofit仅负责网络请求接口的封装
  - App应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数，Header，Url等信息，之后由OkHttp完成后续的请求操作
  - 在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析

![1.Retrofit框架的整体设计](./res7/1.Retrofit框架的整体设计.png)

##### 1.2.

#### 2.Retrofit的基本使用

- 添加依赖

~~~java
    implementation("com.squareup.okhttp3:okhttp:3.9.0")
    implementation 'com.squareup.retrofit2:retrofit:2.1.0'
    implementation 'com.squareup.retrofit2:converter-gson:2.1.0'
~~~

- 定义访问服务器的API

~~~java
public interface ApiServer {
    /**
     * 1.2 首页banner
     * https://www.wanandroid.com/banner/json
     * 方法：GET
     */
    @GET("banner/json")
    Call<HttpResult<List<Banner>>> getBanner();
}
~~~

- 创建Retrofit对象实例，并发起网络请求

~~~java
public class RetrofitStu {
    public void testRetrofit() {
      // 创建Retrofit对象实例
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl("https://www.wanandroid.com/")
                .addConverterFactory(GsonConverterFactory.create())
                .build();
      // 调用Retrofit的create方法获取ApiServer对象实例
        ApiServer apiServer = retrofit.create(ApiServer.class);
        Call<HttpResult<List<Banner>>> bannerCall = apiServer.getBanner();
      // 发起异步请求
        bannerCall.enqueue(new Callback<HttpResult<List<Banner>>>() {
            @Override
            public void onResponse(Call<HttpResult<List<Banner>>> call, 
                                   Response<HttpResult<List<Banner>>> response) {
                HttpResult<List<Banner>> body = response.body();
                List<Banner> bannerList = body.data;
                System.out.println(bannerList.toString());
            }

            @Override
            public void onFailure(Call<HttpResult<List<Banner>>> call, Throwable t) {

            }
        });
    }
}

结果打印：
[Banner{desc='扔物线', id=29, imagePath='https://wanandroid.com/blogimgs/04d6f53b-65e8-4eda-89c0-5981e8688576.png', isVisible=1, order=0, type=0, title='我用 Jetpack Compose 写了个春节版微信主题，带炸弹特效', url='http://i0k.cn/4KryA'}, Banner{desc='', id=6, imagePath='https://www.wanandroid.com/blogimgs/62c1bd68-b5f3-4a3c-a649-7ca8c7dfabe6.png', isVisible=1, order=1, type=1, title='我们新增了一个常用导航Tab~', url='https://www.wanandroid.com/navi'}, Banner{desc='一起来做个App吧', id=10, imagePath='https://www.wanandroid.com/blogimgs/50c115c2-cf6c-4802-aa7b-a4334de444cd.png', isVisible=1, order=1, type=1, title='一起来做个App吧', url='https://www.wanandroid.com/blog/show/2'}, Banner{desc='', id=20, imagePath='https://www.wanandroid.com/blogimgs/90c6cc12-742e-4c9f-b318-b912f163b8d0.png', isVisible=1, order=2, type=1, title='flutter 中文社区 ', url='https://flutter.cn/'}]

~~~

##### 1.1.Retrofit网络通信过程：



#### 2.Retrofit的注解

##### 2.1.HTTP请求方法的注解

- http请求方法注解支持有八种：GET，POST，PUT，DELETE，HEAD，PATCH，OPTIONS，HTTP

##### 2.2.标记类注解

- FormUrlEncoded：指请求体是一个Form表单
- Multipart：指请求体是一个支持文件上传的Form表单
- Streaming：指响应体的数据以流的形式放回

##### 2.3.参数类注解

- Headers：添加请求头，作用于方法
- Header：用于动态添加头部，作用域方法参数
- Body：用于非表单请求体，作用域方法参数
- Url：用于动态改变Url，作用域方法参数
- Path：用于替换请求地址，作用域方法参数
- Field：用于表单字段参数
- FieldMap：用于表单字段参数，接收Map实现多个参数
- Part：用于表单字段参数，适用于文件上传
- PartMap：用于表单字段参数，适用于文件上传
- Query：用于条件字段参数，作用域方法参数
- QueryMap：用于条件字段参数，作用域方法参数

#### 3.Retrofit的配置

##### 3.1.为Retrofit添加Converter转换器

- Retrofit中提供了Converter的概念，直译为转换器，Retrofit正常请求下来后，响应体为ResponseBody类型，我们需要将ResponseBody解析后才能得到我们想要的数据

| 依赖库                                                       | Gradle引用 | 来源 |
| ------------------------------------------------------------ | ---------- | ---- |
| [Gson](https://link.jianshu.com?t=https://github.com/google/gson) com.squareup.retrofit2:converter-gson 官方<br />[Jackson](https://link.jianshu.com?t=http://wiki.fasterxml.com/JacksonHome) com.squareup.retrofit2:converter-jackson 官方  <br />[Moshi](https://link.jianshu.com?t=https://github.com/square/moshi) com.squareup.retrofit2:converter-moshi 官方   <br />[Protobuf](https://link.jianshu.com?t=https://developers.google.com/protocol-buffers/) com.squareup.retrofit2:converter-protobuf 官方   <br />[Wire](https://link.jianshu.com?t=https://github.com/square/wire) com.squareup.retrofit2:converter-wire 官方   <br />[Simple Framework](https://link.jianshu.com?t=http://simple.sourceforge.net/) com.squareup.retrofit2:converter-simpleframework 官方   Scalars com.squareup.retrofit2:converter-scalars 官方   <br />[LoganSquare](https://link.jianshu.com?t=https://github.com/aurae/retrofit-logansquare) com.github.aurae.retrofit2:converter-logansquare 第三方   <br />FastJson org.ligboy.retrofit2:converter-fastjson 或org.ligboy.retrofit2:converter-fastjson-android 第三方 |            |      |

##### 3.2.也可以为Retrofit添加RxJava支持

#### 4.Retrofit的使用流程

##### 4.1.Retrofit通过Builder设计模式构建Retrifit对象

~~~java
public final class Retrofit {
  private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();

  private final okhttp3.Call.Factory callFactory;
  private final HttpUrl baseUrl;
  private final List<Converter.Factory> converterFactories;
  private final List<CallAdapter.Factory> adapterFactories;
  private final Executor callbackExecutor;
  private final boolean validateEagerly;

  Retrofit(okhttp3.Call.Factory callFactory, HttpUrl baseUrl,
           List<Converter.Factory> converterFactories, 
           List<CallAdapter.Factory> adapterFactories,
      Executor callbackExecutor, boolean validateEagerly) {
    this.callFactory = callFactory;
    this.baseUrl = baseUrl;
    this.converterFactories = unmodifiableList(converterFactories); 
    this.adapterFactories = unmodifiableList(adapterFactories); 
    this.callbackExecutor = callbackExecutor;
    this.validateEagerly = validateEagerly;
  }

  public static final class Builder {
    private Platform platform;
    private okhttp3.Call.Factory callFactory;
    private HttpUrl baseUrl;
    private List<Converter.Factory> converterFactories = new ArrayList<>();
    private List<CallAdapter.Factory> adapterFactories = new ArrayList<>();
    private Executor callbackExecutor;
    private boolean validateEagerly;

    Builder(Platform platform) {
      this.platform = platform;
      converterFactories.add(new BuiltInConverters());
    }

    public Builder() {
      this(Platform.get());
    }
    
    public Builder baseUrl(String baseUrl) {
      HttpUrl httpUrl = HttpUrl.parse(baseUrl);
      this.baseUrl = baseUrl;
      return this;
    }
    
    // 转换器工厂是保存在集合中的
    public Builder addConverterFactory(Converter.Factory factory) {
      converterFactories.add(checkNotNull(factory, "factory == null"));
      return this;
    }
		// 调用适配器也是保存在集合中
    public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
      adapterFactories.add(checkNotNull(factory, "factory == null"));
      return this;
    }
    
    // 最后通过build方法创建Retrofit实例
    public Retrofit build() {
      //如果没有设置OkHttpClinet，则使用默认的
      okhttp3.Call.Factory callFactory = this.callFactory;
      if (callFactory == null) {
        callFactory = new OkHttpClient();
      }

      // 创建结果回调，Android端使用Handler进行线程切换
      Executor callbackExecutor = this.callbackExecutor;
      if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
      }
      //设置设配器集合
      List<CallAdapter.Factory> adapterFactories = 
        new ArrayList<>(this.adapterFactories);
      adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

      // 设置转换器集合
      List<Converter.Factory> converterFactories = new ArrayList<>(this.converterFactories);
      return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,
          callbackExecutor, validateEagerly);
    }
  }
}
~~~

#### 4.2.Retrofit的create方法-创建网络请求接口

~~~java
public final class Retrofit {
  private final Map<Method, ServiceMethod> serviceMethodCache = new LinkedHashMap<>();

  private final okhttp3.Call.Factory callFactory;
  private final HttpUrl baseUrl;
  private final List<Converter.Factory> converterFactories;
  private final List<CallAdapter.Factory> adapterFactories;
  private final Executor callbackExecutor;
  private final boolean validateEagerly;

  public <T> T create(final Class<T> service) {
    ...
      // 核心：通过动态代理获取到ApiServer的实例
    return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class<?>[] { service },
        new InvocationHandler() {
          private final Platform platform = Platform.get();

          @Override public Object invoke(Object proxy, Method method, 
                                         Object... args)throws Throwable {
            if (method.getDeclaringClass() == Object.class) {
              return method.invoke(this, args);
            }
            if (platform.isDefaultMethod(method)) {
              return platform.invokeDefaultMethod(method, service, proxy, args);
            }
            ServiceMethod serviceMethod = loadServiceMethod(method);
            OkHttpCall okHttpCall = new OkHttpCall<>(serviceMethod, args);
            return serviceMethod.callAdapter.adapt(okHttpCall);
          }
        });
  }
}
~~~

#### 4.3.获取网络请求Call

#### 4.4.发起网络请求


























