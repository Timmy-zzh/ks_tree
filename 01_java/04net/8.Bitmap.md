

#### 1.Bitmap

- Android App中很多页面都会使用到Bitmap进行图片展示，Bitmap是程序中内存消耗的大户

##### 1.1.Bitmap图片的使用

- 从drawable或mipmap目录中加载一张图片并展示
  - 通过BitmapFactory进行加载

~~~java
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_glode);
        imageView.setImageBitmap(bitmap);
~~~

#### 2.一张Bitmap图片占用内存分析

- 通过Bitmap.getAllocationByteCount() 方法获取Bitmap占用的内存字节大小
- 设备与图片信息：
  - 设备为density=3密度的手机
  - ic_glode.png图片存放在 mip-map-xxhdpi目录下，图片大小为72 * 72

~~~java
public class BitmapActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_bitmap_study);
        ImageView imageView = findViewById(R.id.iv);
      
        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.ic_glode);
        imageView.setImageBitmap(bitmap);
        //求bitmap占用的内存大小
        int byteCount = bitmap.getAllocationByteCount();
        Log.e("Tim", "byteCount:" + byteCount);
    }
}
结果打印：
/Tim: byteCount:20736
~~~

**解析：**

- 使用BitmapFactory加载图片，默认使用的是Bitmap.Config#ARGB_8888的存储方式来加载图片内容，这中存储模式下每一个像素需要占用4个字节，所以上面ic_glode.png图片的内容大小计算如下：

宽 * 高 * 4 = 72 * 72 * 6 = 20736

##### 2.1.屏幕自适应

- 因为我们的手机的屏幕密度density=3，当应用程序去加载图片资源时，
  - 会先到mipmap-xxhdpi目录下进行查找ic_glode.png图片
  - 当该目录下没有ic_glode.png图片时，则会查找其他密度目录下的同名称文件，先查找mipmap-xhdpi，还没有的话，查找mipmap-hdpi  … 

- 将ic_glode.png图片移动到mipmap-xhdpi目录下，查看图片加载后占用内存情况
  - 得到的结果为：/Tim: byteCount:46656
  - 发现只是移动了图片存在的目录，图片加载占用的内容即然翻了2倍多，这是为什么呢？

##### 2.2.要搞清楚上面的问题，首先要了解设备屏幕密度的概念

- 概念



Android中各个drawable目录对应的屏幕密度如下：

|    目录    | drawable-mdpi | drawable-hdpi | drawable-xhdpi | drawable-xxhdpi | drawable-xxxhdpi |
| :--------: | :-----------: | :-----------: | :------------: | :-------------: | :--------------: |
|  density   |       1       |      1.5      |       2        |        3        |        4         |
| densityDpi |      160      |      240      |      320       |       480       |       640        |

- BitmapFactory在解析图片的过程中，会根据当前设备屏幕密度和图片所在的drawable目录进行比对，根据这个对比值进行缩放操作，具体公式如下：

~~~java
缩放比例 scale = 当前设备屏幕密度 / 图片所在 drawable 目录对应屏幕密度
Bitmap 实际大小 = 宽 * scale * 高 * scale * Config 对应存储像素数
~~~

**所以将ic_glode.png图片移动到mipmap-xhdpi目录下，图片占用内存大小为：**

- 72 * （480/320）* 72 *（480/320） * 4 = 46656

##### 2.3.加载assets目录下的图片

- 同样的设备和图片，放在assets资源目录下，内容占用如下：

~~~java
    private void loadAssets() {
        try {
            InputStream is = getAssets().open("ic_glode_res.png");
            Bitmap bitmap = BitmapFactory.decodeStream(is);
            imageView.setImageBitmap(bitmap);
            //求bitmap占用的内存大小
            int byteCount = bitmap.getAllocationByteCount();
            Log.e("Tim", "byteCount:" + byteCount);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
结果打印：
/Tim: byteCount:20736
~~~

- 可以看出，加载assets目录中的图片，系统并不会对其进行缩放操作

#### 3.Bitmap图片加载优化



#### 4.大图加载