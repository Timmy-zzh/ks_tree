https://blog.csdn.net/guolin_blog/article/details/53939176

https://blog.csdn.net/guolin_blog/article/list/2



#### 1.DrawableRequestBuilder.into()方法

~~~java
public class DrawableRequestBuilder<ModelType>
        extends GenericRequestBuilder<ModelType,
								ImageVideoWrapper, GifBitmapWrapper, GlideDrawable>
        implements 
  								BitmapOptions, DrawableOptions {
    DrawableRequestBuilder(Context context, Class<ModelType> modelClass,
            LoadProvider<ModelType, ImageVideoWrapper, 
                           GifBitmapWrapper, GlideDrawable> loadProvider, Glide glide,
            RequestTracker requestTracker, Lifecycle lifecycle) {
        super(context, modelClass, loadProvider, GlideDrawable.class, 
              glide, requestTracker, lifecycle);
        crossFade();
    }
    
    @Override
    public Target<GlideDrawable> into(ImageView view) {
        return super.into(view);
    }
}
~~~

- into方法调用的是父类GenericRequestBuilder的into方法

##### 2.GenericRequestBuilder.into()

~~~java
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType>     
                                             implements Cloneable {
    protected final Class<ModelType> modelClass;
    protected final Context context;
    protected final Glide glide;
    protected final Class<TranscodeType> transcodeClass;
    protected final RequestTracker requestTracker;
    protected final Lifecycle lifecycle;
    private ChildLoadProvider<ModelType, DataType,
         ResourceType, TranscodeType> loadProvider;
    private ModelType model;
    private Key signature = EmptySignature.obtain();
    private boolean isModelSet;
    private int placeholderId;
    private int errorId;
    private RequestListener<? super ModelType, TranscodeType> requestListener;
    private Float thumbSizeMultiplier;
    private GenericRequestBuilder<?, ?, ?, TranscodeType> thumbnailRequestBuilder;
    private Float sizeMultiplier = 1f;
    private Drawable placeholderDrawable;
    private Drawable errorPlaceholder;
    private Priority priority = null;
    private boolean isCacheable = true;
    private GlideAnimationFactory<TranscodeType> animationFactory = NoAnimation.getFactory();
    private int overrideHeight = -1;
    private int overrideWidth = -1;
    private DiskCacheStrategy diskCacheStrategy = DiskCacheStrategy.RESULT;
    private Transformation<ResourceType> transformation = UnitTransformation.get();
    private boolean isTransformationSet;
    private boolean isThumbnailBuilt;
    private Drawable fallbackDrawable;
    private int fallbackResource;
  
    public Target<TranscodeType> into(ImageView view) {
        ...
        if (!isTransformationSet && view.getScaleType() != null) {
            switch (view.getScaleType()) {
                case CENTER_CROP:
                    applyCenterCrop();
                    break;
                case FIT_CENTER:
                case FIT_START:
                case FIT_END:
                    applyFitCenter();
                    break;
                default:
            }
        }
        return into(glide.buildImageViewTarget(view, transcodeClass));
    }
}
~~~

- into方法中最要看最后一行代码
  - glide.buildImageViewTarget(view, transcodeClass)返回的是一个Target对象，我们看下内部实现

##### 3.glide.buildImageViewTarget()

~~~java
public class Glide {
    private static final String TAG = "Glide";
    private static volatile Glide glide;

    private final GenericLoaderFactory loaderFactory;
    private final Engine engine;
    private final BitmapPool bitmapPool;
    private final MemoryCache memoryCache;
    private final DecodeFormat decodeFormat;
    private final ImageViewTargetFactory imageViewTargetFactory = 
                              new ImageViewTargetFactory();
    private final TranscoderRegistry transcoderRegistry = new TranscoderRegistry();
    private final DataLoadProviderRegistry dataLoadProviderRegistry;
    private final CenterCrop bitmapCenterCrop;
    private final GifBitmapWrapperTransformation drawableCenterCrop;
    private final FitCenter bitmapFitCenter;
    private final GifBitmapWrapperTransformation drawableFitCenter;
    private final Handler mainHandler;
    private final BitmapPreFiller bitmapPreFiller;
  
    public static Glide get(Context context) {
        if (glide == null) {
            synchronized (Glide.class) {
                if (glide == null) {
                    Context applicationContext = context.getApplicationContext();
                    List<GlideModule> modules = 
                      new ManifestParser(applicationContext).parse();

                    GlideBuilder builder = new GlideBuilder(applicationContext);
                    for (GlideModule module : modules) {
                        module.applyOptions(applicationContext, builder);
                    }
                    glide = builder.createGlide();
                    for (GlideModule module : modules) {
                        module.registerComponents(applicationContext, glide);
                    }
                }
            }
        }

        return glide;
    }

    <R> Target<R> buildImageViewTarget(ImageView imageView, Class<R> transcodedClass) {
        return imageViewTargetFactory.buildTarget(imageView, transcodedClass);
    }
}
~~~

##### ImageViewTargetFactory.buildTarget()方法

~~~java
public class ImageViewTargetFactory {

    @SuppressWarnings("unchecked")
    public <Z> Target<Z> buildTarget(ImageView view, Class<Z> clazz) {
        if (GlideDrawable.class.isAssignableFrom(clazz)) {
            return (Target<Z>) new GlideDrawableImageViewTarget(view);
        } else if (Bitmap.class.equals(clazz)) {
            return (Target<Z>) new BitmapImageViewTarget(view);
        } else if (Drawable.class.isAssignableFrom(clazz)) {
            return (Target<Z>) new DrawableImageViewTarget(view);
        } else {
            throw new IllegalArgumentException("Unhandled class: " + clazz
                    + ", try .as*(Class).transcode(ResourceTranscoder)");
        }
    }
}
~~~

**解析：**

- buildTarget方法会根据参数class类型返回不同的Target对象实例，如果没有调用asBitmap方法，则clazz是GlideDrawable类型，所以最后返回new GlideDrawableImageViewTarget(view)对象实例
- 每次调用into方法，都会创建一个GlideDrawableImageViewTarget对象实例

##### 4.GenericRequestBuilder.into(Y target)重载方法

~~~java
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> ... {
  
    public <Y extends Target<TranscodeType>> Y into(Y target) {
      //所处线程判断
        Util.assertMainThread();
        ...
        //1.调用target的getRequest方法，获取之前加载的请求
        Request previous = target.getRequest();

        if (previous != null) {
            previous.clear();
            requestTracker.removeRequest(previous);
            previous.recycle();
        }
				//2.buildRequest方法，构造加载该图片的Request请求
        Request request = buildRequest(target);
      // 请求request与target关联
        target.setRequest(request);
      // target添加生命周期监听
        lifecycle.addListener(target);
      //3.调用 RequestTracker的runRequest方法
        requestTracker.runRequest(request);
        return target;
    }
}
~~~

**解析：**

- **核心方法1：**注释2，buildRequest方法构建一个Request对象
- **核心方法2：**接着调用RequestTracker的runRequest方法执行之恶个request
- Request对象是用来发送加载图片请求的

#### 5.GenericRequestBuilder.buildRequest方法

~~~java
public class GenericRequestBuilder<ModelType, DataType, ResourceType, TranscodeType> ... {
  
    private Request buildRequest(Target<TranscodeType> target) {
        if (priority == null) {
            priority = Priority.NORMAL;
        }
        return buildRequestRecursive(target, null);
    }

    private Request buildRequestRecursive(Target<TranscodeType> target, ThumbnailRequestCoordinator parentCoordinator) {
        if (thumbnailRequestBuilder != null) {
            // thumbnailRequestBuilder不为空处理(图片压缩相关)
          ....
            return coordinator;
        } else if (thumbSizeMultiplier != null) {
            // thumbSizeMultiplier不为空处理
          ....
            return coordinator;
        } else {
            // 默认主流程
            return obtainRequest(target, sizeMultiplier, priority, parentCoordinator);
        }
    }

    private Request obtainRequest(Target<TranscodeType> target, 
                                  float sizeMultiplier, Priority priority,
                                  RequestCoordinator requestCoordinator) {
      // 调用GenericRequest的obtain方法构建Request，会传入很多参数，这些参数都是我们前面调用设置的
        return GenericRequest.obtain(
                loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderId,
                errorPlaceholder,
                errorId,
                fallbackDrawable,
                fallbackResource,
                requestListener,
                requestCoordinator,
                glide.getEngine(),
                transformation,
                transcodeClass,
                isCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
    }
}
~~~

**解析：** buildRequest方法构建一个Request对象实例，内部由GenericRequest实现。

- GenericRequest类中有一个请求队列池，底层数据结构为ArrayDeque，前面几次发起请求的时候，队列为空，会通过new GenericRequest构建Request对象
- 当图片请求结束后，会调用Request的recycle方法，这个时候请求队列池ArrayDeque会将该Request对象入队列保存起来
- 后面再发起图片请求，要求构建Request时，会从请求队列池中，出队列获取Request对象，这样做的目的可以在有多个请求图片时，可以复用已经请求结束的请求对象，不用每次请求都new一个GenericRequest对象实例，在多图加载时提升性能

##### 6.执行请求 RequestTracker.runRequest

~~~java
public class RequestTracker {
  // 保存请求的Set集合，底层使用的是WeakHashMap
    private final Set<Request> requests 
                    = Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
  // 请求等待集合
    private final List<Request> pendingRequests = new ArrayList<Request>();
  // 界面生命周期是否是paused？
    private boolean isPaused;

  // 请求执行
    public void runRequest(Request request) {
      // 添加到请求集合
        requests.add(request);
        if (!isPaused) {		// 如果当前界面是active，则调用request的begin方法--开始执行请求
            request.begin();
        } else {
          // 如果当前界面的生命周期是pause，则当前请求添加到等待集合中
            pendingRequests.add(request);
        }
    }

    void addRequest(Request request) {
        requests.add(request);
    }

    public void removeRequest(Request request) {
        requests.remove(request);
        pendingRequests.remove(request);
    }

    public boolean isPaused() {
        return isPaused;
    }

  // 请求暂停，将所有正在执行的请求调用pause，并添加到等待队列中
    public void pauseRequests() {
        isPaused = true;
        for (Request request : Util.getSnapshot(requests)) {
            if (request.isRunning()) {
                request.pause();
                pendingRequests.add(request);
            }
        }
    }

    // 界面生命周期回到resume，将等待队列中的请求从新开始执行
    public void resumeRequests() {
        isPaused = false;
        for (Request request : Util.getSnapshot(requests)) {
            if (!request.isComplete() && !request.isCancelled() && !request.isRunning()) {
                request.begin();
            }
        }
        pendingRequests.clear();
    }

    public void clearRequests() {
        for (Request request : Util.getSnapshot(requests)) {
            request.clear();
        }
        pendingRequests.clear();
    }

    public void restartRequests() {
        for (Request request : Util.getSnapshot(requests)) {
            if (!request.isComplete() && !request.isCancelled()) {
                request.pause();
                if (!isPaused) {
                    request.begin();
                } else {
                    pendingRequests.add(request);
                }
            }
        }
    }
}
~~~

**解析：**

- RequestTracker是图片请求GenericRequest的管理者，内部通过Set集合对象保存正在执行的请求，和等待队列
- 他在RequestManager构造函数中进行初始化，并根据界面生命周期的变化，对图片请求队列进行控制
  - Fragment的生命周期先传递给RequestManager，然后在RequestManager中根据生命周期方法不同，通过RequestTracker方法对请求队列进行暂停和重新开始执行操作

#### 7.请求开始执行：GenericRequest.begin() 

~~~java
public final class GenericRequest<A, T, Z, R> implements Request, 
        SizeReadyCallback,ResourceCallback {
          
    private static final String TAG = "GenericRequest";
          //请求队列池
    private static final Queue<GenericRequest<?, ?, ?, ?>> REQUEST_POOL 
                  = Util.createQueue(0);
    private static final double TO_MEGABYTE = 1d / (1024d * 1024d);

          // 枚举，请求各种状态
    private enum Status {
        PENDING,
        RUNNING,
        WAITING_FOR_SIZE,
        COMPLETE,
        FAILED,
        CANCELLED,
        CLEARED,
        PAUSED,
    }

    private final String tag = String.valueOf(hashCode());

    private Key signature;
    private Drawable fallbackDrawable;
    private int fallbackResourceId;
    private int placeholderResourceId;
    private int errorResourceId;
    private Context context;
    private Transformation<Z> transformation;
    private LoadProvider<A, T, Z, R> loadProvider;
    private RequestCoordinator requestCoordinator;
    private A model;
    private Class<R> transcodeClass;
    private boolean isMemoryCacheable;
    private Priority priority;
    private Target<R> target;
    private RequestListener<? super A, R> requestListener;
    private float sizeMultiplier;
    private Engine engine;
    private GlideAnimationFactory<R> animationFactory;
    private int overrideWidth;
    private int overrideHeight;
    private DiskCacheStrategy diskCacheStrategy;
    private Drawable placeholderDrawable;
    private Drawable errorDrawable;
    private boolean loadedFromMemoryCache;
    private Resource<?> resource;
    private Engine.LoadStatus loadStatus;
    private long startTime;
    private Status status;

          // 构建一个新的Request请求
    public static <A, T, Z, R> GenericRequest<A, T, Z, R> obtain(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            Drawable fallbackDrawable,
            int fallbackResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
      
      // 先从队列池中获取，没有则new，最后调用 request.init方法，将传入的参数进行赋值
        GenericRequest<A, T, Z, R> request = 
                      (GenericRequest<A, T, Z, R>) REQUEST_POOL.poll();
        if (request == null) {
            request = new GenericRequest<A, T, Z, R>();
        }
        request.init(loadProvider,
                model,
                signature,
                context,
                priority,
                target,
                sizeMultiplier,
                placeholderDrawable,
                placeholderResourceId,
                errorDrawable,
                errorResourceId,
                fallbackDrawable,
                fallbackResourceId,
                requestListener,
                requestCoordinator,
                engine,
                transformation,
                transcodeClass,
                isMemoryCacheable,
                animationFactory,
                overrideWidth,
                overrideHeight,
                diskCacheStrategy);
        return request;
    }

    private GenericRequest() {
        // just create, instances are reused with recycle/init
    }

          // 请求结束后调用，将请求入队列池
    @Override
    public void recycle() {
        loadProvider = null;
        model = null;
        context = null;
        target = null;
        placeholderDrawable = null;
        errorDrawable = null;
        fallbackDrawable = null;
        requestListener = null;
        requestCoordinator = null;
        transformation = null;
        animationFactory = null;
        loadedFromMemoryCache = false;
        loadStatus = null;
        REQUEST_POOL.offer(this);
    }

    private void init(
            LoadProvider<A, T, Z, R> loadProvider,
            A model,
            Key signature,
            Context context,
            Priority priority,
            Target<R> target,
            float sizeMultiplier,
            Drawable placeholderDrawable,
            int placeholderResourceId,
            Drawable errorDrawable,
            int errorResourceId,
            Drawable fallbackDrawable,
            int fallbackResourceId,
            RequestListener<? super A, R> requestListener,
            RequestCoordinator requestCoordinator,
            Engine engine,
            Transformation<Z> transformation,
            Class<R> transcodeClass,
            boolean isMemoryCacheable,
            GlideAnimationFactory<R> animationFactory,
            int overrideWidth,
            int overrideHeight,
            DiskCacheStrategy diskCacheStrategy) {
      //参数赋值
        ...
    }

    private static void check(String name, Object object, String suggestion) {
        if (object == null) {
            StringBuilder message = new StringBuilder(name);
            message.append(" must not be null");
            if (suggestion != null) {
                message.append(", ");
                message.append(suggestion);
            }
            throw new NullPointerException(message.toString());
        }
    }

    //请求开始执行
    @Override
    public void begin() {
        startTime = LogTime.getLogTime();
      // 如果model为空，onException()方法会调用 setErrorPlaceholder(e);并直接return
      //最后会将设置的error占位图进行展示
        if (model == null) {
            onException(null);
            return;
        }

        status = Status.WAITING_FOR_SIZE;
        if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
            onSizeReady(overrideWidth, overrideHeight);
        } else {
          // target为GlideDrawableImageViewTarget类对象，最后都会调用onSizeReady()方法
            target.getSize(this);
        }

        if (!isComplete() && !isFailed() && canNotifyStatusChanged()) {
          //占位图展示loading图片
            target.onLoadStarted(getPlaceholderDrawable());
        }
    }

    void cancel() {
        status = Status.CANCELLED;
        if (loadStatus != null) {
            loadStatus.cancel();
            loadStatus = null;
        }
    }

    @Override
    public void clear() {
        Util.assertMainThread();
        if (status == Status.CLEARED) {
            return;
        }
        cancel();
        if (resource != null) {
            releaseResource(resource);
        }
        if (canNotifyStatusChanged()) {
            target.onLoadCleared(getPlaceholderDrawable());
        }
        status = Status.CLEARED;
    }

    @Override
    public boolean isPaused() {
        return status == Status.PAUSED;
    }

    @Override
    public void pause() {
        clear();
        status = Status.PAUSED;
    }

    private void releaseResource(Resource resource) {
        engine.release(resource);
        this.resource = null;
    }

    @Override
    public boolean isRunning() {
        return status == Status.RUNNING || status == Status.WAITING_FOR_SIZE;
    }

    @Override
    public boolean isComplete() {
        return status == Status.COMPLETE;
    }

    @Override
    public boolean isResourceSet() {
        return isComplete();
    }

    @Override
    public boolean isCancelled() {
        return status == Status.CANCELLED || status == Status.CLEARED;
    }

    @Override
    public boolean isFailed() {
        return status == Status.FAILED;
    }

    private Drawable getFallbackDrawable() {
      if (fallbackDrawable == null && fallbackResourceId > 0) {
        fallbackDrawable = context.getResources().getDrawable(fallbackResourceId);
      }
      return fallbackDrawable;
    }

    private void setErrorPlaceholder(Exception e) {
        if (!canNotifyStatusChanged()) {
            return;
        }

        Drawable error = model == null ? getFallbackDrawable() : null;
        if (error == null) {
          error = getErrorDrawable();
        }
        if (error == null) {
            error = getPlaceholderDrawable();
        }
        target.onLoadFailed(e, error);
    }

    private Drawable getErrorDrawable() {
        if (errorDrawable == null && errorResourceId > 0) {
            errorDrawable = context.getResources().getDrawable(errorResourceId);
        }
        return errorDrawable;
    }

    private Drawable getPlaceholderDrawable() {
        if (placeholderDrawable == null && placeholderResourceId > 0) {
            placeholderDrawable = context.getResources().getDrawable(placeholderResourceId);
        }
        return placeholderDrawable;
    }

     // 核心方法：
    @Override
    public void onSizeReady(int width, int height) {
        if (status != Status.WAITING_FOR_SIZE) {
            return;
        }
        status = Status.RUNNING;
        width = Math.round(sizeMultiplier * width);
        height = Math.round(sizeMultiplier * height);

      // 调用LoadProvider的getModelLoader方法获取ModelLoader对象，
      // ---实现类为ImageVideoModelLoader对象实例
      // laodProvider是DataLoadProvider对象实例，在DrawableTypeRequest的构造函数中初始化
        ModelLoader<A, T> modelLoader = loadProvider.getModelLoader();
      // 接着调用ImageVideoModelLoader的getResourceFetcher方法，返回DataFetcher的是ImageVideoFetcher实现类
        final DataFetcher<T> dataFetcher = modelLoader.
                                getResourceFetcher(model, width, height);
        ...
          //获取的是GlideBitmapDrawableTranscoder实现类对象，在Glide构造函数中初始化
        ResourceTranscoder<Z, R> transcoder = loadProvider.getTranscoder();
        loadedFromMemoryCache = true;
      // 核心方法：调用Engine的load方法
      // Engine是类com.bumptech.glide.load.engine.Engine
        loadStatus = engine.load(signature, width, height,
                                 dataFetcher, loadProvider, 
                                 transformation, transcoder,
                priority, isMemoryCacheable, diskCacheStrategy, this);
        loadedFromMemoryCache = resource != null;
    }

    private boolean canSetResource() {
        return requestCoordinator == null || requestCoordinator.canSetImage(this);
    }

    private boolean canNotifyStatusChanged() {
        return requestCoordinator == null || requestCoordinator.canNotifyStatusChanged(this);
    }

    private boolean isFirstReadyResource() {
        return requestCoordinator == null || !requestCoordinator.isAnyResourceSet();
    }

    private void notifyLoadSuccess() {
      if (requestCoordinator != null) {
        requestCoordinator.onRequestSuccess(this);
      }
    }

    @SuppressWarnings("unchecked")
    @Override
    public void onResourceReady(Resource<?> resource) {
        if (resource == null) {
            onException(new Exception("Expected to receive a Resource<R> with an object of " + transcodeClass
                    + " inside, but instead got null."));
            return;
        }

        Object received = resource.get();
        if (received == null || !transcodeClass.isAssignableFrom(received.getClass())) {
            releaseResource(resource);
            onException(new Exception("Expected to receive an object of " + transcodeClass
                    + " but instead got " + (received != null ? received.getClass() : "") + "{" + received + "}"
                    + " inside Resource{" + resource + "}."
                    + (received != null ? "" : " "
                        + "To indicate failure return a null Resource object, "
                        + "rather than a Resource object containing null data.")
            ));
            return;
        }

        if (!canSetResource()) {
            releaseResource(resource);
            // We can't set the status to complete before asking canSetResource().
            status = Status.COMPLETE;
            return;
        }

        onResourceReady(resource, (R) received);
    }

    private void onResourceReady(Resource<?> resource, R result) {
        // We must call isFirstReadyResource before setting status.
        boolean isFirstResource = isFirstReadyResource();
        status = Status.COMPLETE;
        this.resource = resource;

        if (requestListener == null || !requestListener.onResourceReady(result, model, target, loadedFromMemoryCache,
                isFirstResource)) {
            GlideAnimation<R> animation = animationFactory.build(loadedFromMemoryCache, isFirstResource);
            target.onResourceReady(result, animation);
        }

        notifyLoadSuccess();

        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            logV("Resource ready in " + LogTime.getElapsedMillis(startTime) + " size: "
                    + (resource.getSize() * TO_MEGABYTE) + " fromCache: " + loadedFromMemoryCache);
        }
    }

    @Override
    public void onException(Exception e) {
        status = Status.FAILED;
        if (requestListener == null || !requestListener.onException(e, model, target,      
                                                                    isFirstReadyResource())) 					{
            setErrorPlaceholder(e);
        }
    }
}
~~~

**解析：**

- GenericRequest的角色是，每次加载图片都会构建一个GenericRequest请求对象，构建过程中在构造函数设置了很多入参
  - 构建过程使用了队列池，提升性能
- 请求执行调用的是GenericRequest的begin方法，
  - target.getSize()方法会获取ImageView的宽高，这个宽高就是图片展示的大小，
  - 最后都会调用onSizeReady方法

- 在onSizeReady中，会获取之前设置好的各种属性（loadProvider，dataFetcher，transformation等）
- 最后调用Engine的load方法

#### 8.Engine.load()方法

~~~java
public class Engine implements EngineJobListener,
        MemoryCache.ResourceRemovedListener,
        EngineResource.ResourceListener {
    private static final String TAG = "Engine";
    private final Map<Key, EngineJob> jobs;
    private final EngineKeyFactory keyFactory;
          //内存缓存
    private final MemoryCache cache;
    private final EngineJobFactory engineJobFactory;
          //活动缓存
    private final Map<Key, WeakReference<EngineResource<?>>> activeResources;
    private final ResourceRecycler resourceRecycler;
    private final LazyDiskCacheProvider diskCacheProvider;
    private ReferenceQueue<EngineResource<?>> resourceReferenceQueue;
          
    public Engine(MemoryCache memoryCache, 
                  DiskCache.Factory diskCacheFactory, 
                  ExecutorService diskCacheService,
            ExecutorService sourceService) {
        this(memoryCache, diskCacheFactory, diskCacheService, sourceService, null, null, null, null, null);
    }

    Engine(MemoryCache cache, DiskCache.Factory diskCacheFactory,
           ExecutorService diskCacheService,
            ExecutorService sourceService, Map<Key, EngineJob> jobs,
           EngineKeyFactory keyFactory,
            Map<Key, WeakReference<EngineResource<?>>> activeResources, 
           EngineJobFactory engineJobFactory,
            ResourceRecycler resourceRecycler) {
        this.cache = cache;
        this.diskCacheProvider = new LazyDiskCacheProvider(diskCacheFactory);

        if (activeResources == null) {
            activeResources = new HashMap<Key, WeakReference<EngineResource<?>>>();
        }
        this.activeResources = activeResources;

        if (keyFactory == null) {
            keyFactory = new EngineKeyFactory();
        }
        this.keyFactory = keyFactory;

        if (jobs == null) {
            jobs = new HashMap<Key, EngineJob>();
        }
        this.jobs = jobs;

        if (engineJobFactory == null) {
            engineJobFactory = new EngineJobFactory(diskCacheService, sourceService, this);
        }
        this.engineJobFactory = engineJobFactory;

        if (resourceRecycler == null) {
            resourceRecycler = new ResourceRecycler();
        }
        this.resourceRecycler = resourceRecycler;

        cache.setResourceRemovedListener(this);
    }

    // 核心方法：
    public <T, Z, R> LoadStatus load(Key signature, int width,
                                     int height, DataFetcher<T> fetcher,
                                     DataLoadProvider<T, Z> loadProvider, 
                                     Transformation<Z> transformation, 
                                     ResourceTranscoder<Z, R> transcoder,
                                     Priority priority, boolean isMemoryCacheable, 
                                     DiskCacheStrategy diskCacheStrategy,
                                     ResourceCallback cb) {
      
        Util.assertMainThread();
        long startTime = LogTime.getLogTime();
        final String id = fetcher.getId();
      //获取EnginKey值，这个key是图片用于缓存的key值
        EngineKey key = keyFactory.buildKey(id, signature, 
                                            width, height, loadProvider.getCacheDecoder(),
                loadProvider.getSourceDecoder(), transformation, loadProvider.getEncoder(),
                transcoder, loadProvider.getSourceEncoder());

      // 从缓存中获取：
        EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
        if (cached != null) {
            cb.onResourceReady(cached);
            return null;
        }

      // 从活动缓存中获取
        EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
        if (active != null) {
            cb.onResourceReady(active);
            return null;
        }

      // 默认第一次EngineJob为null
        EngineJob current = jobs.get(key);
        if (current != null) {
            current.addCallback(cb);
            return new LoadStatus(cb, current);
        }

      // 新建EngineJob和EngineRunnable对象，并调用EngineJob的start方法开始执行EngineRunnable
        EngineJob engineJob = engineJobFactory.build(key, isMemoryCacheable);
        DecodeJob<T, Z, R> decodeJob = new DecodeJob<T, Z, R>(key, width, height, 
                                                              fetcher, loadProvider, 
                                                              transformation,
                                                              transcoder, 
                                                              diskCacheProvider, 
                                                              diskCacheStrategy,
                                                              priority);
        EngineRunnable runnable = new EngineRunnable(engineJob, decodeJob, priority);
        jobs.put(key, engineJob);
        engineJob.addCallback(cb);
        engineJob.start(runnable);
				//最后返回一个LoadStatus对象
        return new LoadStatus(cb, engineJob);
    }
}
~~~

**解析：**

- Engine在Glide构造函数中初始化
- 在load方法中
  - 创建当前图片请求的EngineKey key值
  - 根据key值，先去获取缓存中的图片资源EngineResource
  - 接着查看活动缓存是否有数据
  - 缓存没有，则要去网络中获取了，通过创建EngineJob和EngineRunnable对象，并调用EngineJob的start方法开始执行EngineRunnable
- 如果从缓存中获取EngineResource图片资源成功，则回调cb.onResourceReady(cached)

#### 9.EngineRunnable的run方法

~~~java




~~~



https://blog.csdn.net/guolin_blog/article/details/53939176





