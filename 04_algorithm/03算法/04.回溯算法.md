#### 回溯算法

##### 1.算法思想

- 回溯算法实际上是一种试探算法，这种算法跟暴力搜索最大的不同在于，在回溯算法里，是一步一步地进行向前试探。
  - 会对每一步探测到的情况进行评估，如果当前的情况已经无法满足要求，那么就没有必要继续进行下去（剪枝操作）
- 回溯算法的特点在于，当出现非法的情况时，算法可以回退到之前的情景，可以是返回一步，有时候甚至返回多步，然后再去尝试别的路径或办法。回溯算法必须保证每次都有多种尝试的可能

##### 2.算法解题步骤

- 1.判断当前情况是否非法，如果非法就立即返回
- 2.当前情况是否已经满足递归结束条件，如果是就将当前结果保存起来并返回
- 3.当前情况下，遍历所有可能出现的情况并进行下一步的尝试
- 4.递归完毕后，立即回溯，回溯的方法就是取消前一步进行的尝试

**代码模版：**

~~~c
function fn(n) {

    // 第一步：判断输入或者状态是否非法？
    if (input/state is invalid) {
        return;
  }

    // 第二步：判读递归是否应当结束?
    if (match condition) {
        return some value;
  }

    // 遍历所有可能出现的情况
    for (all possible cases) {
  
        // 第三步: 尝试下一步的可能性
        solution.push(case)
        // 递归
        result = fn(m)

        // 第四步：回溯到上一步
        solution.pop(case)
    
    }
}
~~~

#### 3.回溯算法

- 递归算法为基础，不断遍历深度优先遍历所有的路径，然后归来的时候不断将状态回归到调用前
- 在不断往下递归的时候判断是否满足条件将本次路径结果保存到结果集中，并判断终止条件返回

~~~java
模版代码
void backtrace(int[] A,
               int i, /*第i个人*/
               Box s, /*箱子*/
               answer/*存放所有的答案*/) {
  final int N = A == null ? 0 : A.length;
  if (状态满足要求) {
    	answer.add(s);
  }
  
  if ([i, ...., 后面）的人都没有任何选项了) {
    return;
  }
       
  for 宝石 in {第i个人当前所有宝石选项} {
    s.push(宝石);
    backtrace(A, i + 1, s, answer);
    s.pop();
  }
}
~~~

##### 思考点

- 1个核心：第i个人怎么选
- 3个条件：
  - 什么样的状态是我们想要的？
  - 后面的人还有选项吗？如果后面所有的人都没有选项，就需要返回
  - 第i个人的宝石选项是什么样的？

#### 4.问题类型

- 排列组合问题
  - 电话号码的字母组合
- 子集
- 

























