#### 1.优先队列

##### 特点：

- 能保证每次取出的元素都是队列中优先级别最高的。
- 优先级别可以自定义，例如，数据的数值越大，优先级别越高，或者数据的数值越小，优先级越高，也可以通过自定义的计算得到

##### 应用场景：

- 从一堆杂乱无章的数据当中按照一定的顺序逐步地筛选出部分乃至全部的数据

#### 2.优先队列的本质

- 优先队列的本质是一个**二叉堆**结构（Binary Heap），它是利用一个**数组结构来实现的完全二叉树**。
- 优先队列的**底层实现是一个数组**，数组里的每个元素即可能是其他元素的父节点，也有可能是其他元素的子节点，而且，每个父节点只能有两个子节点，很像一棵二叉树的结构

##### 优先队列的三个重要性质：

- 1.数组里的第一个元素array[0]拥有最高的优先级别
- 2.给定一个下标i，那么对于元素array[i] 而言：
  - 他的父节点所对应的元素下标为 (i-1)/2
  - 他的左孩子所对应的元素下标为 2*i +1
  - 他的右孩子所对应的元素下标为 2*i +2
- 3.数组里每个元素的优先级别都要高于他的两个孩子的优先级别

#### 3.优先队列的基本操作

##### 3.1.向上刷选（新增元素）

- 当有新的数据加入到优先队列中，新的数据首先被放置到二叉堆的底部
- 不断进行向上刷选的操作，即如果发现该数据的优先级别比父节点的优先级别还要高，那么就和父节点的元素进行交换，再接着往上进行比较，知道无法在继续交换为止
- 时间复杂度：由于二叉堆是一棵完全二叉树，并假设堆的大小为k，因此整个过程其实就是沿着树的高度往上爬，所以只需要O(log k) 的时间

##### 3.2.向下刷选

- 当堆顶的元素被取出时，需要将堆底部的元素放置到堆顶位置，然后不断地对他执行向下刷选的操作
- 将该元素和他的两个孩子节点对比优先级，如果优先级最高的是其中一个孩子，就将该元素和那个孩子进行交换，然后反复进行下去，知道无法继续交换为止

#### 初始化

- 有n个数据，需要创建一个大小为n的堆
- 因为在创建堆的过程中，二叉树的大小是从1逐步增长到n的，所以整个算法的复杂度为O(n)

















