#### 1.KMP算法

##### 核心思想：字符串匹配时充分利用模式串特征和此前比对信息，减少比对次数。

- 使用场景：常用于在一个文本串S内查找一个模式串P的首次出现位置
- 实现方案：
  - 分析模式串特征，**next[]数组保存模式串中前后缀最长重复子串长度**
  - 每次回溯时，通过next[]找到前面匹配过的位置

#### 2.next[]数组解析

**2.1.模式串特征分析目标：**当匹配不成功时找到最理想的模式串移动位置

- 该字符不匹配时，模式串下一次比对位置
- 该位置前的前缀，后缀匹配的最大长度
- 第0个位置前面无字符，值为-1

##### 2.2.next[]数组求值

遍历每一个字符计算next[j]，**数组元素的值保存模式串中前后缀最长重复子串长度**

- 1.初始next[0]为-1
- 2.双指针比对前缀k，后缀j
- 3.相等，双指针都后移： 用前缀下标k填充next[j]
- 4.不想等前缀k指针回溯： 回溯时利用已计算的next[k]
- 5.前缀指针为-1，则需要对双指针都后移，用前缀下标k填充next[j]

#### 3.KMP算法实现步骤

核心思想：利用next数组加速比对，双指针遍历比对文本串i和模式串j

- 1.若字符相同，双指针后移
- 2.若字符不相同：
  - 若next[j]为-1，则 i 后移，j置为0
  - 否则 j 回溯到next[j]位置
- 3.若模式串到达最后一个字符
  - 匹配成功，返回对应起始索引 i-j