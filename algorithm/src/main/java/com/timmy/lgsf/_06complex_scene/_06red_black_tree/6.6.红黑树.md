#### 红黑树

#### 1.Hash碰撞问题

- 开放寻址法，和链地址法 —>会导致Hash表降级为链表结构
  - JDK1.7中HashMap是由数组和链表组成的
  - 当Hash发生碰撞时，查询时间复杂度为O(n)
- JDK1.8中，当链表长度达到8时，转为红黑树以提升性能
  - 红黑树的查询时间复杂度为O(log n)

#### 2.概念

##### 二叉搜素树

- 一颗空树或者满足以下性质的二叉树被称为二叉搜素树：
  - 如果左子树不为空，则左子树所有的节点值都小于跟节点的值
  - 如果右子树不为空，则右子树所有节点值都大雨或等于跟节点的值
  - 任意一颗子树也是一颗二叉搜索树
- 二叉搜素树的查找时间复杂度为O(log n),极端情况下降低到O(n)

##### 平衡树（Balance Tree）

- 任意节点的子树的高度差都小于等于1
- 常见的平衡树包括B树（MySQL中的索引），AVL树等

##### 平衡二叉搜索树（AVL树）

- 同时满足二叉搜索树和平衡树的特点
- 可以有效的减少二叉树的深度，从而提高了查询的效率
- 严格平衡，代价高

##### 3.红黑树（Red Black Tree :RB Tree）：自平衡的二叉搜索树

- 红黑树是一种特化的AVL树（平衡二叉搜索树），**在插入和删除时通过特定操作保持二叉查找树的相对平衡**，从而**获得较高的查找性能。**
- 不是严格的AVL树，只是黑色平衡：如下图
  - 根节点P的左子树显然比右子树高
  - 但左子树和右子树的黑节点的层数是想等的
  - 叶子节点默认存在两个黑色节点的空节点

![Algorithm](/Users/zhuzhonghua036/study1/github/ks_tree/algorithm/src/main/java/com/timmy/lgsf/_06complex_scene/_06red_black_tree/res/Algorithm.png)

##### 红黑树特点：

- 符合二叉搜索树的基本特性
- 节点非黑即红（每个节点要么是黑色，要么是红色）
- 其根节点是黑色
- 叶子节点是黑色
- 相邻节点不同为红色（红色节点的子节点必是黑色）
- 从一个节点到该节点的下叶子节点的所有路径上包含的黑色节点数量相等（这是平衡的关键点）

##### 总结：黑根黑叶红不邻，同祖等高只数黑

#### 4.左右旋

##### 左旋：

- 以某节点作为旋转节点，其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变。
- **口诀：**左旋左不变，与右互换放左边，右由右左来补全
  - 左旋的话，旋转节点的左边不变，旋转节点与右子节点交换，右子节点变为父节点，旋转节点变为原先右子节点的左边作为左子节点
  - 并且原先右子节点的左右子节点，其中左子节点会掉落，放在旋转节点的右子节点上

##### 右旋：

- 以某个节点作为旋转节点，其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。
- **口诀：**右旋右不变，与左呼唤放右边，左由左右来补全

#### 5.删除节点



























