1. 可达性分析
2. GCRoot场景
3. 垃圾回收算法
4. 分代回收策略
5. 引用



#### 垃圾回收

- 垃圾回收（Garbage Collection,简写为GC），相较于C语言开发需要手动释放内存，jvm中的垃圾回收器会自动回收
- 程序运行时的内存区域，其中程序计数器，虚拟机栈和本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出执行者入栈和出栈操作，这三个区域都不需要过多考虑内存回收的问题
- 而堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才能知道会创建那些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注就是这部分内存

##### 什么是垃圾

- 垃圾就是内存中已经没有用的对象。要进行垃圾回收，必须先知道那些对象是垃圾；
- java虚拟机中使用一种叫做**可达性分析**的算法来决定那些对象是否可以被回收

#### 可达性分析

可达性分析算法是从离散数学中的图论引入的，jvm把内存中所有的对象之间的引用关系看作一张图，通过一组名为**GC Root**的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，最后通过判断对象的引用链是否可达来决定对象是否可以被回收。如下图所示：

<img src=".\res2\1.可达性分析.png" alt="1.可达性分析" style="zoom:50%;" />

- 上图中，对象A/B/C/D/E与GC Root之间都存在一条直接或间接的引用链，表示他们与GC Root之间是可达的，因此他们是不能被GC回收掉的。
- 而对象M，K虽然被J引用到，但是并不存在一条引用链连接他们与GC Root，所以当GC进行垃圾回收时，只要遍历到J/K/M，3个对象那个就会将他们回收

#### GC Root对象

在java中，有以下几种对象可以作为GC Root：

1. Java虚拟机栈（局部变量表）中引用的对象
2. 方法区中静态引用指向的对象
3. 仍处于存活状态中的线程对象
4. Native方法中JNI引用的对象

##### GC回收时机

1. Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次GC
2. System.gc():在应用层，Java开发工程师可以主动调用此API来请求一次GC



#### 垃圾回收算法

##### 1.标记清除算法

从GC Roots集合开始，将内存整个遍历一次，保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收，过程分为两步：

- 1.Mark标记阶段：找到内存中的所有GC Root对象，只要是和GC Root对象直接或间接相连则标记为灰色（也就是存活对象），否则标记为黑色（也就是垃圾对象）
- 2.Sweep清除阶段：当遍历完所有的GC Root之后，则将标记为垃圾的对象直接清除

如下图所示：

<img src=".\res2\2.标记清除算法.png" alt="2.标记清除算法" style="zoom:80%;" />

- 优缺点：
  - 优点：实现简单，不需要将对象进行移动
  - 缺点：这个算法需要中断进程内其他组件的执行（Stop The World），并且可能产生内存碎片，提高了垃圾回收频率

##### 2.复制算法

将现有的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中存活对象复制到未被使用的内存块中。之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

- 1.复制算法之前，内存分为A/B两块，并且当前只是用内存A，内存状况如下图

<img src=".\res2\3.复制算法1.png" alt="3.复制算法1" style="zoom:80%;" />

- 标记完之后，所有可达对象都被按次序复制到内存B中，并设置B为当前使用中的内存。

<img src=".\res2\3.复制算法2.png" alt="3.复制算法1" style="zoom:80%;" />

- 优缺点
  - 优点：按顺序分配内存即可，实现简单，运行高校，不用考虑内存碎片
  - 缺点：可用的内存大小缩小为原来的一般，对象存活率高时会频繁进行复制操作

##### 3.标记-压缩算法

需要先从根节点开始对所有可达对象做一次标记，之后，并不是简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一段。最后，清理边界外所有的空间。

- 1.Mark标记阶段：找到内存中所有GC Root对象，只要是和GC Root对象直接或间接相连则标记为灰色存活对象，否则标记为黑色垃圾对象
- 2.Compact压缩阶段：将剩余存活对象按顺序压缩到内存的某一端

<img src=".\res2\4.标记压缩算法.png" alt="4.标记压缩算法" style="zoom:80%;" />

- 优缺点
  - 优点：这种方法即避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高
  - 缺点：所谓压缩操作，需要对局部对象移动，所以一定程度上还是降低了效率



#### JVM分代回收策略

- java虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代，老年代，这就是JVM的内存分代策略
  - 注意在HotSpot中除了新生代和老年代，还有永久代
- 分代回收的中心思想就是：

















