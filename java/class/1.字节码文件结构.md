#### 1.Class字节码文件由来

- Java能够实现“一次编译，到处运行”，其中class文件要占大部分功劳。
  - 为了让Java语言具有良好的跨平台能力，Java提供了一种可以在所有平台上都能使用的一种中间代码-字节码类文件(.class文件)
  - 有了字节码，无论哪种平台（Mac，Windows，Linux等），只要安装了虚拟机都可以直接运行字节码

- 有了字节码，也解除了Java虚拟机和Java语言之间的耦合
  - Java虚拟机也支持很多除Java语言以外的其他语言，如Groovy，JRuby，Jython，Scala等，因为这些语言经过编译之后也可以生成能够被JVM解析并执行的字节码文件。
- 虚拟机不关系字节码是由那种语言编译而来的。

<img src=".\res1\1.字节码与虚拟机解耦.png" alt="1.字节码与虚拟机解耦" style="zoom:80%;" />

#### 2.class文件组成

**class文件里只有两种数据结构：无符号数和表**

- 无符号数：属于基本的数据类型
  - 以u1，u2，u4，u8。来分别代表1个字节，2个字节，4个字节和8个字节的无符号数，
  - 无符号数可以用来描述数字，索引引用，数量值或者字符串
- 表：
  - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型。
  - class文件中所有的表都以"_info"结尾，整个class文件本质上就是一张表。

表和无符号数之间的关系：

<img src=".\res1\2.表和无符号数之间的关系.png" alt="2.表和无符号数之间的关系" style="zoom:80%;" />

伪代码如下：

~~~java
// 无符号数
u1 = byte[1];
u2 = byte[2];
u4 = byte[4];
u8 = byte[8];

// 表
class_table {
    // 表中可以引用各种无符号数，
    u1 tag;
    u2 index2;
    ...
    // 表中也可以引用其它表
    method_table mt;
    ...
}
~~~

#### 3.class文件结构

- class文件中只存在无符号数和表两种数据结构。
  - 这些无符号数和表组成了class中的各个结构；
  - 这些结构按照**预先规定好的顺序**紧密的从前向后排列，相邻的项之间没有任何间隙。

- class文件结构

| 魔数 | 版本号 | 常量池 | 访问标志 | 类/父类/接口 | 字段描述集合 | 方法描述集合 | 属性描述集合 |
| ---- | ------ | ------ | -------- | ------------ | ------------ | ------------ | ------------ |
|      |        |        |          |              |              |              |              |

当JVM加载某个class文件时，jvm就是根据上图中的结构去解析class文件，加载class文件到内存中，并在内存中分配相应的空间。具体某一种结构需要占用多大空间，如下图：

|        字段         |       名称       |    数据类型    |         数量          |
| :-----------------: | :--------------: | :------------: | :-------------------: |
|    magic number     |       魔数       |       u4       |           1           |
|    major version    |     主版本号     |       u2       |           1           |
|    minor version    |     副版本号     |       u2       |           1           |
| constant_pool_count |    常量池大小    |       u2       |           1           |
|    constant_pool    |      常量池      |    cp_info     | constant_pool_count-1 |
|     access_flag     |     访问标志     |       u2       |           1           |
|     this_class      |    当前类索引    |       u2       |           1           |
|     super_class     |     父类索引     |       u2       |           1           |
|  interfaces_count   | 接口索引集合大小 |       u2       |           1           |
|     interfaces      |   接口索引集合   |       u2       |   interfaces_count    |
|    fields_count     | 字段索引集合大小 |       u2       |           1           |
|       fields        |   字段索引集合   |   field_info   |     fields_count      |
|    methods_count    | 方法索引集合大小 |       u2       |           1           |
|       methods       |   方法索引集合   |  method_info   |     methods_count     |
|  attributes_count   | 属性索引集合大小 |       u2       |           1           |
|     attributes      |   属性索引集合   | attribute_info |   attributes_count    |

- 无符号数，表，class结构关系
  - class文件中的无符号和表相当于人类身体中的H，O，C，N等元素
  - 而class结构图中的各项结果相当于人类身体的各个器官
  - 并且这些器官的组织顺序是有严格顺序要求的

#### 4.实例分析

~~~java
import java.io.Serializable;

public class Test implements Serializable, Cloneable {

    private int num = 1;
    public int add(int i) {
        int j = 10;
        num = num + i;
        return num;
    }
}
~~~

- 通过javac编译，生成Test.class字节码，然后使用16进制编辑器打开class文件，查看内容
  - 下图中都是一些16进制数字，每两个字符代表一个字节

<img src=".\res1\3.class内存(16进制).png" alt="3.class内存(16进制)" style="zoom:100%;" />

- 其Test.class文件对应的字节码文件：javac -> javap -v Test.class

<img src=".\res1\7.class字节码文件1.png" alt="7.class字节码文件1" style="zoom:99%;" />

<img src=".\res1\7.class字节码文件2.png" alt="7.class字节码文件2" style="zoom:99%;" />

##### 魔数 magic number

~~~~java
CA FE BA BE
~~~~

- class文件开头的四个字节时class文件的魔数，它是一个固定的值--0XCAFEBABE
- 魔数是class文件的标志，是判断一个文件是不是class格式文件的标准，如果开头四个字节不是0XCAFEBABE，就说明不是class文件，不能被JVM识别或加载

##### 版本号

~~~java
00 00 00 34
~~~

- 跟在魔数后面的四个字节代表当前class文件的版本号。
  - 前两个字节0000代表次版本号（minor_version）,后两个字节0034是主版本号（major_version）,对应十进制值为52.
  - 也就是说当前class文件的主版本号为52，次版本号为0。也就是jdk1.8.0

##### 常量池

- 紧跟在版本号之后的是一个叫做常量池的表（cp_info）.
- 在常量池中保存了类的各种相关信息，比如类的名称，父类的名称，类中的方法名，参数名称，参数类型等，这些信息都是以各种表的形式保存在常量池中的

**常量池中的每一项都是一个表，其项目类型共有14种，如下表：**

|               表名               | 标识位(Tag) |           描述           |
| :------------------------------: | :---------: | :----------------------: |
|        CONSTANT_utf8_info        |      1      |    UTF_8编码字符串表     |
|      CONSTANT_Integer_info       |      3      |        整形常量表        |
|       CONSTANT_Float_info        |      4      |       浮点型常量表       |
|        CONSTANT_Long_info        |      5      |       长整型常量表       |
|       CONSTANT_Double_info       |      6      |    双精度浮点型常量表    |
|       CONSTANT_Class_info        |      7      |      类/接口 引用表      |
|       CONSTANT_String_info       |      8      |       字符串常量表       |
|      CONSTANT_Fieldref_info      |      9      |        字段引用表        |
|     CONSTANT_Methodref_info      |     10      |      类的方法引用表      |
| CONSTANT_InterfaceMethodref_info |     11      |     接口的方法引用表     |
|    CONSTANT_NameAndType_info     |     12      | 字段或方法的名称和类型表 |
|    CONSTANT_MethodHandle_info    |     15      |        方法句柄表        |
|     CONSTANT_MethodType_info     |     16      |        方法类型表        |
|   CONSTANT_InvokeDynamic_info    |     18      |      动态方法调用表      |

- 常量池种的每一项都会由一个u1大小的tag值，tag值是表的标识，jvm解析class文件时，通过这个值来判断当前数据数据结果是哪一种表。

以CONSTANT_Class_info和CONSTANT_utf8_info两张表距离说明：

**CONSTANT_Class_info表具体结果如下：**

~~~java
table CONSTANT_Class_info {
    u1  tag = 7;
    u2  name_index;
}
~~~

- 解析
  - tag：占用一个字节大小。不如值位7，说明是CONSTANT_Class_info类型表
  - name_index：是一个索引值，可以将它理解为一个指针，指向常量池种索引为name_index的常量表。比如name_index=2，则它指向常量池种第2个常量

**CONSTANT_utf8_info表具体结果如下：**

~~~java
table CONSTANT_utf8_info {
    u1  tag;
    u2  length;
    u1[] bytes;
}
~~~

- 解析
  - tag：值为1，表示是CONSTANT_utf8_info类型表
  - length：length表示u1[]的长度，比如length=5，则表示接下来的数据是5个连续的u1类型数据
  - bytes：u1类型数组，长度为length的值
- 在java代码中声明的String字符串最终在class文件中的存储格式就是CONSTANT_utf8_info。因此一个字符串最大长度就是u2所能代表的最大值65535（2的16次方），但是需要使用2个字节来保存null值，因此一个字符串的最大长度为65535-2=65534.

在常量池内部的表中也有相互之间的引用。用一张图来理解CONSTANT_Class_info和CONSTANT_utf8_info表格之间的关系，如图：

<img src=".\res1\4.常量池中表之间的关系.png" alt="4.常量池中表之间的关系" style="zoom:80%;" />

##### 接着往下解析，常量池元素个数

- 因为开发者平时定义的java类各式各样，类中的方法与参数也不尽相同。所以常量池的元素数量也就无法固定。
- 因此class文件在常量池的前面使用2个字节的容器计数器，用来代表当前类中常量池的大小。
- 如下图，红色框中的0017转换为十进制为23，也就是说常量计数器的值为23.其中下标为0的常量被jvm留作其他用途，因此Test.class中实际常量池大小为这个计数器的值减1，为22个

![5.常量池数量大小](.\res1\5.常量池数量大小.png)

- 第一个常量，如下图

![6.常量池第一个长岭](.\res1\6.常量池第一个常量.png)

	- 0A转化为十进制为10，通过查看常量池14种类型表格，tag=10的表类型为CONSTANT_Methodref_info，因此常量池种的第一个常量类型为方法引用表，结果如下：

~~~java
CONSTANT_Methodref_info {
    u1 tag = 10;
    u2 class_index;        指向此方法的所属类
    u2 name_type_index;    指向此方法的名称和类型
}
~~~

 - 也就是说在“0A”之后的2个字节指向这个方法是属于哪个类的，紧接的2个字节指向这个方法的名称和类型，他们的值分别为：
   	- 0004：十进制4，表示指向常量池种的第4个常量
   	- 0011：十进制17，表示指向常量池中的第17个常量
- 接着看第二个常量

<img src=".\res1\7.常量池第二个常量.png" alt="7.常量池第二个常量" style="zoom:80%;" />

























