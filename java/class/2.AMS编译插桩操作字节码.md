##### 前言

- 做Android开发大多遇到到这种需求：
  - 记录每一个页面的打开和关闭事件，并通过各种DataTracking框架上传到服务器，用来日后做数据分析
- 面对这样的需求，一般人会想到在每一个Activity的 onCreate 和 onDestory 方法中，分别添加页面打开和页面关闭的逻辑，常见做法如下：
  - 修改项目中现有的每一个Activity，这样存在的问题是，项目以后添加新的页面，这套逻辑需要重新拷贝一遍，很容易遗漏
  - 将项目中所有的Activity继承自BaseActivity，将页面打开和关闭的逻辑添加在BaseActivity中，这种方案看起来比第1种方案高级很多，并且后续项目有新的Activity，直接继承BaseActvity即可。
    - 但是这种方案对第三方依赖库种的界面则无能为力，因为我们没有第三方依赖库的源码

#### 编译插桩

- 编译插桩就是在代码编译期间修改已有的代码或者生成新代码。

- 编译插桩的时机

理解编译插桩之前，先回顾一下Android项目中.java文件的编译过程：

<img src=".\res2\1.java文件编译过程.png" alt="1.java文件编译过程" style="zoom:80%;" />

- 从上图可以看出，可以在1，2处对代码进行改造
  - 在.java文件编译成.class文件时，APT，AndroidAnnotation等就是在此处触发代码生成的。
  - 在.class文件进一步优化成.dex文件时，也就是直接操作字节码。这种方式功能更加强大，应用场景也更多。但是门槛比较高，需要对字节码有一定的理解。

使用一张图来描述ASM框架对字节码操作的流程：

<img src=".\res2\2.AMS框架操作字节码流程.png" alt="2.AMS框架操作字节码流程" style="zoom:80%;" />

##### 案例实现

使用ASM实现在每一个Activity打开时输出相应的log日志

**实现思路**

1. 遍历项目中所有的.class文件
   - 如何找到项目中编译生成的.class文件，这是我们需要解决的第一个问题。
   - 可以自定义Transform，来获取所有的.class文件引用，但是Transform的使用需要依赖Gradle Plugin。
   - 因此第一步需要创建一个单独的Gradle Plugin，并在Gradle Plugin中使用自定义的Transform找出所有的.class文件。
2. 遍历到目标.class文件（Activity）之后，通过ASM动态注入需要被插入的字节码
   - 如果第一步进行顺利，可以找出所有的.class文件。
   - 接下来就需要过滤出目标Activity文件，并在目标Activity文件的onCreate 方法中，通过ASM插入相应的log日志字节码

#### 具体实现：































