##### 前言

之前介绍了Java字节码文件(.class)的格式。

- 一个完整的Java程序由多个.class文件组成，在程序运行过程中，需要将这些.class文件加载到JVM中才可以使用。
- 而负责加载这些.class文件的就是类加载器-ClassLoader

#### Java中的类何时被加载器加载

- 在Java程序启动的时候，并不会一次性加载程序中所有的.class文件，而是在程序运行过程中，动态地加载相应的类到内存中（方法区）
- 通常情况下Java程序中的.class文件会在以下2种情况被ClassLoader主动加载到内存中
  - 调用类构造器
  - 调用类中的静态（static）变量或者静态方法

#### Java中的ClassLoader

- JVM中自带3个类加载器
  - 启动类加载器 BootstrapClassLoader
  - 扩展类加载器 ExtClassLoader
  - 系统加载器 APPClassLoader

##### 系统加载器 APPClassLoader

~~~java
    static class AppClassLoader extends URLClassLoader {
        final URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(this);

        public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException {
            final String var1 = System.getProperty("java.class.path");
            final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1);
            return (ClassLoader)AccessController.doPrivileged(new PrivilegedAction<Launcher.AppClassLoader>() {
                public Launcher.AppClassLoader run() {
                    URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2);
                    return new Launcher.AppClassLoader(var1x, var0);
                }
            });
        }
~~~

- AppClassLoader主要加载系统属性“java.class.path”配置下类文件，也就是环境变量CLASS_PATH配置的路径
- 因此AppClassLoader是面向用户的类加载器，我们编写的代码以及使用的第三方jar包通常都是由他来加载的

##### 扩展类加载器 ExtClassLoader

~~~java
        private static Launcher.ExtClassLoader createExtClassLoader() throws IOException {
            try {
                return (Launcher.ExtClassLoader)AccessController.doPrivileged(new PrivilegedExceptionAction<Launcher.ExtClassLoader>() {
                    public Launcher.ExtClassLoader run() throws IOException {
                        File[] var1 = Launcher.ExtClassLoader.getExtDirs();
                        int var2 = var1.length;

                        for(int var3 = 0; var3 < var2; ++var3) {
                            MetaIndex.registerDirectory(var1[var3]);
                        }

                        return new Launcher.ExtClassLoader(var1);
                    }
                });
            } catch (PrivilegedActionException var1) {
                throw (IOException)var1.getException();
            }
        }
        
        private static File[] getExtDirs() {
            String var0 = System.getProperty("java.ext.dirs");
            File[] var1;
            ...
            return var1;
        }
~~~

- ExtClassLoader主要加载系统属性"java.ext.dirs"配置下类文件。

##### 启动类加载器 BootstrapClassLoader

- BootstrapClassLoader不是用Java代码实现的，而是由C/C++语言编写的，本身属于虚拟机的一部分。
- 其加载系统属性 “sun.boot.class.path”配置下类文件。

代码实现：

~~~java
    public static void main(String[] args) {
        System.out.println(System.getProperty("java.class.path"));
        System.out.println("------------------------");
        System.out.println(System.getProperty("java.ext.dirs"));
        System.out.println("------------------------");
        System.out.println(System.getProperty("sun.boot.class.path"));
    }
~~~

打印效果：

<img src=".\res3\1.JVM中三个类加载器.png" alt="1.JVM中三个类加载器" style="zoom:90%;" />

#### 双亲委派模式

##### 问题：既然JVM中已经有了3中ClassLoader，那么我们编写的.class文件到底该使用哪一个类加载器去加载呢？  

答案是：双亲委派模式

- 双亲委派模式就是，当类加载器收到加载类或资源的请求时，通常都是先委托给父类加载器加载。
  - 也就是说，只有当父类加载器找不到指定类或资源时，自身才会执行实际的类加载过程

































